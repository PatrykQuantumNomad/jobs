---
phase: 18-resume-tailoring-via-cli-sse
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - webapp/app.py
  - webapp/templates/partials/resume_tailor_status.html
  - webapp/templates/job_detail.html
autonomous: true

must_haves:
  truths:
    - "POST /jobs/{key}/tailor-resume returns an SSE-connect HTML snippet immediately (not blocking for 10-15s)"
    - "GET /jobs/{key}/tailor-resume/stream yields progress, done, and error events via SSE"
    - "Resume tailoring pipeline runs as a background asyncio.Task emitting stage events (extracting, generating, validating, rendering)"
    - "Anti-fabrication validation still runs and its results appear in the final done event"
    - "PDF is rendered, version is saved, and activity is logged -- same as before"
    - "tailor_resume() internally calls claude_cli.run() which launches a CLI subprocess -- this was established in Phase 16-02 and is preserved here (RES-01)"
    - "If the SSE connection closes (user navigates away), the background task is cancelled and the session is cleaned up"
    - "Double-click on Tailor Resume returns 'already in progress' instead of starting a second pipeline"
  artifacts:
    - path: "webapp/app.py"
      provides: "SSE-backed tailor_resume_endpoint + resume_tailor_stream + _run_resume_tailor background task"
      contains: "_resume_sessions"
    - path: "webapp/templates/partials/resume_tailor_status.html"
      provides: "SSE event rendering for progress/done/error states"
    - path: "webapp/templates/job_detail.html"
      provides: "Updated Tailor Resume button with hx-target pointing to SSE container"
  key_links:
    - from: "webapp/app.py::tailor_resume_endpoint"
      to: "webapp/app.py::_run_resume_tailor"
      via: "asyncio.create_task + asyncio.Queue"
      pattern: "_resume_sessions\\[dedup_key\\]"
    - from: "webapp/app.py::resume_tailor_stream"
      to: "webapp/templates/partials/resume_tailor_status.html"
      via: "templates.get_template render per event"
      pattern: "resume_tailor_status\\.html"
    - from: "webapp/app.py::_run_resume_tailor"
      to: "resume_ai/tailor.py::tailor_resume"
      via: "await tailor_resume()"
      pattern: "await tailor_resume"
    - from: "webapp/app.py::_run_resume_tailor"
      to: "resume_ai/renderer.py::render_resume_pdf"
      via: "asyncio.to_thread (blocking WeasyPrint call)"
      pattern: "asyncio\\.to_thread.*render_resume_pdf"
---

<objective>
Convert the resume tailoring endpoint from a synchronous request-response pattern to SSE-backed streaming with real-time progress events through four pipeline stages.

Purpose: Users currently see a frozen spinner for 10-15 seconds during resume tailoring. After this plan, they see live progress through each stage (extracting, generating, validating, rendering), matching the SSE pattern already working for the apply engine.

Output: Modified webapp/app.py with SSE endpoints, new resume_tailor_status.html partial, updated job_detail.html button wiring.
</objective>

<execution_context>
@/Users/patrykattc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrykattc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-resume-tailoring-via-cli-sse/18-RESEARCH.md
@webapp/app.py
@webapp/templates/job_detail.html
@webapp/templates/partials/apply_status.html
@apply_engine/events.py
@resume_ai/tailor.py
@resume_ai/validator.py
@resume_ai/renderer.py
@resume_ai/tracker.py
@resume_ai/extractor.py
@resume_ai/diff.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build SSE resume tailoring pipeline and endpoints</name>
  <files>webapp/app.py, webapp/templates/partials/resume_tailor_status.html, webapp/templates/job_detail.html</files>
  <action>
  **In `webapp/app.py`:**

  1. Add module-level session tracking dicts (place them right above the existing `tailor_resume_endpoint`, near the "Resume AI endpoints" section comment):

  ```python
  _resume_sessions: dict[str, asyncio.Queue] = {}
  _resume_tasks: dict[str, asyncio.Task] = {}
  ```

  2. Create the `_run_resume_tailor` background task function (place it right after the session dicts). This function follows the same structure as the existing `_run_apply` function (line 538), but runs the full resume tailoring pipeline with stage progress events. Key implementation details:

  - Accept parameters: `dedup_key: str, job: dict, resume_path: str, queue: asyncio.Queue`
  - Use lazy imports inside the function for all resume_ai modules (same pattern as the current `tailor_resume_endpoint`)
  - Define an inner `_emit(event_type, message, html="")` helper that calls `queue.put_nowait({"type": event_type, "message": message, "html": html})`
  - Run 4 stages with progress events between them:
    - Stage 1 "extracting": `resume_text = await asyncio.to_thread(extract_resume_text, resume_path)` (sync function, wrap in to_thread)
    - Stage 2 "generating": `tailored = await tailor_resume(resume_text=..., job_description=..., job_title=..., company_name=...)` (already async -- internally calls `claude_cli.run()` which launches a CLI subprocess; this was converted in Phase 16-02 and satisfies RES-01)
    - Stage 3 "validating": Run `format_resume_as_text(tailored)` then `validate_no_fabrication(original, tailored_text)` (fast sync, no need for to_thread)
    - Stage 4 "rendering": Build output_path using the same slug logic as the current endpoint, then `await asyncio.to_thread(render_resume_pdf, tailored, name, contact_info, output_path)` (CPU-bound WeasyPrint). After PDF, call `save_resume_version(...)` and `db.log_activity(...)` (both fast sync, ok inline)
  - After stage 4, build the final result HTML by rendering `partials/resume_diff.html` via `templates.get_template("partials/resume_diff.html").render(...)` with the same context variables as the current endpoint (diff_html, download_url, tailoring_notes, filename, validation_valid, validation_warnings)
  - Emit `_emit("done", "Resume tailored successfully", html=result_html)`
  - Catch `asyncio.CancelledError`: emit `_emit("done", "Generation cancelled")` and re-raise
  - Catch `Exception as exc`: `logger.exception(...)`, emit `_emit("error", f"Resume tailoring failed: {exc}")`, then emit `_emit("done", "")`
  - Use try/except structure (NOT try/finally for the done event, to avoid double-done -- "done" is emitted explicitly in success path, error path, and cancel path)

  3. **Replace** the existing `tailor_resume_endpoint` function (the one starting at line 248 with `@app.post("/jobs/{dedup_key:path}/tailor-resume"`). The new version:

  - Keep the same decorator and function signature: `async def tailor_resume_endpoint(request: Request, dedup_key: str)`
  - Job lookup: `job = db.get_job(dedup_key)`, return 404 if not found (same as now)
  - Session dedup check: if `dedup_key in _resume_sessions`, return `HTMLResponse('<div class="...">Resume generation already in progress...</div>')`
  - Resolve resume path (same pattern as current code -- try config, fallback to DEFAULT_RESUME_PATH)
  - Create queue: `queue = asyncio.Queue()`
  - Store session: `_resume_sessions[dedup_key] = queue`
  - Start background task: `task = asyncio.create_task(_run_resume_tailor(dedup_key, job, resume_path, queue))`
  - Store task: `_resume_tasks[dedup_key] = task`
  - Return HTML with SSE connection:
    ```python
    encoded_key = urllib.parse.quote(dedup_key, safe="")
    return HTMLResponse(
        f'<div hx-ext="sse"'
        f' sse-connect="/jobs/{encoded_key}/tailor-resume/stream"'
        f' sse-swap="progress"'
        f' sse-close="done">'
        f'  <div class="flex items-center gap-2 py-2">'
        f'    <div class="animate-spin h-4 w-4 border-2 border-indigo-500'
        f' border-t-transparent rounded-full"></div>'
        f'    <span class="text-sm text-gray-500">Starting resume tailoring...</span>'
        f'  </div>'
        f'</div>'
    )
    ```

  4. Add the SSE stream endpoint right after the trigger endpoint. Follow the exact pattern of `apply_stream` (line 602):

  ```python
  @app.get("/jobs/{dedup_key:path}/tailor-resume/stream")
  async def resume_tailor_stream(request: Request, dedup_key: str):
      """SSE endpoint streaming real-time resume tailoring progress."""
      from sse_starlette import EventSourceResponse

      queue = _resume_sessions.get(dedup_key)
      if queue is None:
          return HTMLResponse(
              "<p class='text-red-600 text-sm'>No active resume session</p>",
              status_code=404,
          )

      async def event_generator():
          try:
              while True:
                  if await request.is_disconnected():
                      break
                  try:
                      event = await asyncio.wait_for(queue.get(), timeout=15)
                      event_type = event.get("type", "progress")
                      html = templates.get_template(
                          "partials/resume_tailor_status.html"
                      ).render(event=event, dedup_key=dedup_key)
                      yield {"event": event_type, "data": html}
                      if event_type == "done":
                          break
                  except TimeoutError:
                      yield {"event": "ping", "data": ""}
          except asyncio.CancelledError:
              pass
          finally:
              _resume_sessions.pop(dedup_key, None)
              task = _resume_tasks.pop(dedup_key, None)
              if task and not task.done():
                  task.cancel()

      return EventSourceResponse(event_generator())
  ```

  NOTE: The stream endpoint MUST be registered BEFORE the catch-all `GET /jobs/{dedup_key:path}` route. Place it alongside the other resume AI endpoints in the existing "Resume AI endpoints" section.

  **In `webapp/templates/partials/resume_tailor_status.html`:**

  Create a new partial template for SSE events. Follow the same structure as `apply_status.html`:

  ```html
  {# Resume tailoring SSE status partial -- rendered per event and swapped via sse-swap="progress" #}

  {% if event.type == "progress" %}
  <div class="flex items-center gap-2 py-2">
      <div class="animate-spin h-4 w-4 border-2 border-indigo-500 border-t-transparent rounded-full"></div>
      <span class="text-sm text-gray-700">{{ event.message }}</span>
  </div>

  {% elif event.type == "error" %}
  <div class="bg-red-50 border border-red-400 text-red-800 px-4 py-3 rounded">
      <p class="text-sm font-medium">Error</p>
      <p class="text-sm">{{ event.message }}</p>
  </div>

  {% elif event.type == "done" %}
  {% if event.html %}
  {{ event.html | safe }}
  {% elif event.message %}
  <div class="bg-gray-50 border border-gray-300 text-gray-700 px-4 py-3 rounded">
      <p class="text-sm">{{ event.message }}</p>
  </div>
  {% endif %}

  {% else %}
  <div class="py-2">
      <span class="text-sm text-gray-500">{{ event.message }}</span>
  </div>
  {% endif %}
  ```

  Key design decisions for this template:
  - For "done" events with `html` content (the normal success path), render the full `resume_diff.html` partial content that was pre-rendered in the background task. This is the final state that replaces the SSE container.
  - For "done" events without html (cancellation, error-then-done), show a simple message.
  - Use indigo-500 spinner (matching the "Tailor Resume" button color), unlike apply_status.html which uses purple-500.

  **In `webapp/templates/job_detail.html`:**

  Update the "AI Resume Tools" sidebar card. The existing "Tailor Resume" button at line 141 uses `hx-indicator="#resume-spinner"` for a frozen spinner. Change it to use the SSE pattern:

  - Remove `hx-indicator="#resume-spinner"` from the Tailor Resume button (the SSE events will handle progress display)
  - Keep `hx-post`, `hx-target="#resume-ai-result"`, and `hx-swap="innerHTML"` -- these are correct. The POST returns the SSE-connect div which gets swapped into `#resume-ai-result`, then the SSE events stream progress into that div.
  - Add `hx-disabled-elt="this"` to the button so it becomes disabled while the POST is in flight and while the SSE container is active (prevents double-click)
  - Leave the Cover Letter button unchanged (Phase 19)
  - Leave `#resume-spinner` in place but it will no longer be triggered by the Tailor Resume button -- the Cover Letter button still uses it

  Specifically, change the Tailor Resume button from:
  ```html
  <button hx-post="/jobs/{{ job.dedup_key | urlencode }}/tailor-resume"
          hx-target="#resume-ai-result"
          hx-swap="innerHTML"
          hx-indicator="#resume-spinner"
          class="w-full bg-indigo-600 text-white px-4 py-2 rounded text-sm hover:bg-indigo-700 mb-2">
      Tailor Resume
  </button>
  ```
  To:
  ```html
  <button hx-post="/jobs/{{ job.dedup_key | urlencode }}/tailor-resume"
          hx-target="#resume-ai-result"
          hx-swap="innerHTML"
          hx-disabled-elt="this"
          class="w-full bg-indigo-600 text-white px-4 py-2 rounded text-sm hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed mb-2">
      Tailor Resume
  </button>
  ```
  </action>
  <verify>
  1. `uv run ruff check webapp/app.py webapp/templates/` -- no lint errors
  2. `uv run ruff format --check webapp/app.py` -- formatting OK
  3. Grep for `_resume_sessions` in webapp/app.py -- should appear in 3+ locations (declaration, trigger, stream, background task)
  4. Grep for `resume_tailor_status.html` -- should appear in webapp/app.py (stream endpoint) and exist as a file
  5. Verify the new SSE stream endpoint is registered BEFORE the catch-all GET route by checking line order in app.py
  6. `uv run pytest tests/ -x --timeout=30` -- full test suite passes (existing tests should not break since the endpoint contract is the same POST path, but now returns different HTML)
  </verify>
  <done>
  POST /jobs/{key}/tailor-resume returns an SSE-connect div immediately. GET /jobs/{key}/tailor-resume/stream yields SSE events. The background task runs all 4 pipeline stages with progress events. Anti-fabrication validation runs and appears in the final done event HTML. Session cleanup happens on disconnect. Double-click protection via session check.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for SSE resume tailoring pipeline</name>
  <files>tests/webapp/test_resume_sse.py</files>
  <action>
  Create a new test file `tests/webapp/test_resume_sse.py` for the SSE resume tailoring endpoints. Use the existing `tests/webapp/conftest.py` client fixture and `tests/conftest.py` mock_claude_cli fixture.

  **Test helpers:**
  - `_make_job_dict(company, title, **kwargs)` -- same helper pattern as test_endpoints.py
  - `_compute_dedup_key(company, title)` -- same helper as test_endpoints.py
  - Helper to insert a job with a description long enough for processing

  **Tests to write (mark all with `@pytest.mark.integration` on the class):**

  1. **test_tailor_resume_returns_sse_connect_html** -- POST to tailor-resume endpoint with a valid job returns 200 and HTML containing `sse-connect` and `tailor-resume/stream`. This proves the endpoint no longer blocks for 10-15s. Use `mock_claude_cli` fixture with a mock `TailoredResume` response. Also mock `extract_resume_text` to return a fixed string (avoid needing a real PDF), and mock `render_resume_pdf` and `save_resume_version` (avoid WeasyPrint). Verify response contains `sse-connect`.

  2. **test_tailor_resume_404_for_missing_job** -- POST with a nonexistent dedup_key returns 404. No mocking needed.

  3. **test_tailor_resume_already_in_progress** -- Manually insert a queue into `_resume_sessions` dict before calling POST. Verify the response contains "already in progress". Clean up the dict after.

  4. **test_stream_404_for_no_session** -- GET /jobs/{key}/tailor-resume/stream without an active session returns 404.

  5. **test_background_task_emits_stage_events** -- This tests `_run_resume_tailor` directly (not through HTTP). Create a queue, mock all resume_ai functions (extract_resume_text, tailor_resume, validate_no_fabrication, render_resume_pdf, save_resume_version, format_resume_as_text, generate_resume_diff_html, wrap_diff_html) and db.log_activity. Call `_run_resume_tailor` as an awaitable (not as a task). Collect all events from the queue. Assert:
     - At least 4 "progress" events were emitted (one per stage)
     - Progress messages contain stage keywords: "Extracting", "Generating", "Validating", "Rendering"
     - The last event type is "done"
     - The "done" event has non-empty "html" content

  6. **test_background_task_emits_error_on_failure** -- Same as above but mock `tailor_resume` to raise `RuntimeError`. Assert the queue contains an "error" event followed by a "done" event.

  **Important test patterns:**
  - Use `mock_claude_cli` fixture for any test that involves the actual endpoint (tests 1, 2, 3 trigger endpoint code paths that may import resume_ai modules)
  - For test 5 and 6, mock at the module level inside `_run_resume_tailor` using `unittest.mock.patch`
  - All tests are `async` since the functions under test are async. Use `@pytest.mark.asyncio`
  - Import `_resume_sessions` from `webapp.app` to manipulate session state in test 3
  - Import `_run_resume_tailor` from `webapp.app` for direct testing in tests 5-6
  - After tests that manipulate `_resume_sessions`, clean up via `_resume_sessions.pop(key, None)` in a finally block
  </action>
  <verify>
  1. `uv run pytest tests/webapp/test_resume_sse.py -v` -- all 6 tests pass
  2. `uv run pytest tests/ -x --timeout=30` -- full test suite passes with no regressions
  3. `uv run ruff check tests/webapp/test_resume_sse.py` -- no lint errors
  </verify>
  <done>
  6 tests verify: SSE-connect HTML returned by trigger, 404 handling, double-click protection, stream 404 without session, background task stage events (4 stages + done), error propagation. Full test suite passes with no regressions.
  </done>
</task>

</tasks>

<verification>
1. `uv run ruff check .` -- zero lint errors across entire codebase
2. `uv run ruff format --check .` -- formatting consistent
3. `uv run pytest tests/ -x --timeout=30` -- full suite passes
4. Verify `webapp/app.py` contains `_resume_sessions`, `_resume_tasks`, `_run_resume_tailor`, `resume_tailor_stream`
5. Verify `webapp/templates/partials/resume_tailor_status.html` exists and handles progress/done/error
6. Verify `webapp/templates/job_detail.html` Tailor Resume button no longer has `hx-indicator` and has `hx-disabled-elt`
7. Grep for `sse-connect.*tailor-resume/stream` in webapp/app.py -- confirms SSE wiring
</verification>

<success_criteria>
- POST /jobs/{key}/tailor-resume returns SSE-connect HTML immediately (not blocking)
- SSE stream yields 4+ progress events (extracting, generating, validating, rendering) plus done
- Anti-fabrication validation runs and results appear in final HTML
- PDF rendering, version tracking, and activity logging all still work
- Session cleanup on disconnect (no zombie tasks)
- Double-click protection returns "already in progress"
- 6+ new tests pass, zero regressions in full suite
- Requirements RES-01 through RES-04 addressed
</success_criteria>

<output>
After completion, create `.planning/phases/18-resume-tailoring-via-cli-sse/18-01-SUMMARY.md`
</output>
