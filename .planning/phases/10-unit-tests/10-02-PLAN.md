---
phase: 10-unit-tests
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test_scorer.py
autonomous: true

must_haves:
  truths:
    - "A perfect-match job (exact target title, 5+ tech keywords, remote, $200K+ salary) scores 5"
    - "A zero-match job (unrelated title, no tech overlap, on-site, no salary) scores 1"
    - "Score breakdown captures per-factor points (title 0-2, tech 0-2, remote 0-1, salary 0-1) and matched keywords"
    - "ScoreBreakdown.display_inline() produces format 'Title +N | Tech +N | Remote +N | Salary +N = N'"
    - "Custom ScoringWeights change the final score (e.g., zeroing salary weight removes salary influence)"
    - "score_batch() scores all jobs in-place, sets status to SCORED, and sorts descending"
    - "Scorer constructed with explicit profile and weights never calls get_settings()"
  artifacts:
    - path: "tests/test_scorer.py"
      provides: "UNIT-03 and UNIT-04: Job scoring correctness and score breakdown tests"
      contains: "class TestScoring"
  key_links:
    - from: "tests/test_scorer.py"
      to: "scorer.py"
      via: "Direct import of JobScorer, ScoreBreakdown"
      pattern: "from scorer import"
    - from: "tests/test_scorer.py"
      to: "models.py"
      via: "Direct construction of CandidateProfile and Job"
      pattern: "from models import CandidateProfile, Job"
    - from: "tests/test_scorer.py"
      to: "config.py"
      via: "Direct construction of ScoringWeights"
      pattern: "from config import ScoringWeights"
---

<objective>
Write unit tests for the job scoring engine (UNIT-03: scoring correctness, UNIT-04: score breakdown).

Purpose: The scorer is the most complex pure-logic module. It takes a Job and produces a 1-5 score using weighted factors (title, tech, remote, salary). Tests must verify deterministic scoring with known inputs, correct breakdown reporting, and weight customization -- all without touching config files.

Output: tests/test_scorer.py with comprehensive tests for scoring, breakdown, batch operations, and weight customization.
</objective>

<execution_context>
@/Users/patrykattc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrykattc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-unit-tests/10-RESEARCH.md
@scorer.py
@models.py
@config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tests/test_scorer.py for UNIT-03 (scoring correctness)</name>
  <files>tests/test_scorer.py</files>
  <action>
Create comprehensive unit tests for the scoring engine. Mark all tests with `@pytest.mark.unit`.

**CRITICAL: Never construct `JobScorer()` without passing `profile` and `weights` explicitly.** The constructor falls back to `get_settings()` which loads config.yaml -- this must be avoided in unit tests.

Create a module-level helper to build a deterministic scorer:

```python
from models import CandidateProfile, Job, JobStatus
from config import ScoringWeights
from scorer import JobScorer, ScoreBreakdown


def _make_scorer(
    target_titles=None,
    tech_keywords=None,
    desired_salary_usd=200_000,
    weights=None,
):
    """Build a scorer with explicit profile and weights (no config file)."""
    profile = CandidateProfile(
        target_titles=target_titles or [
            "Senior Software Engineer",
            "Principal Engineer",
            "Staff Engineer",
            "Platform Engineering Lead",
            "DevOps Lead",
        ],
        tech_keywords=tech_keywords or [
            "python", "kubernetes", "terraform", "docker", "aws",
        ],
        desired_salary_usd=desired_salary_usd,
    )
    return JobScorer(profile=profile, weights=weights or ScoringWeights())


def _make_job(**kwargs):
    """Build a Job with sensible defaults for scoring tests."""
    defaults = {
        "platform": "indeed",
        "title": "Software Developer",
        "company": "TestCo",
        "url": "https://example.com/job",
        "location": "",
        "description": "",
    }
    defaults.update(kwargs)
    return Job(**defaults)
```

**class TestTitleScoring:**
- `test_exact_target_title_scores_2`: title="Principal Engineer" -> title_points=2
- `test_target_title_substring_scores_2`: title="Senior Principal Engineer at Google" -> title_points=2 (substring match)
- `test_keyword_match_scores_1`: title="Lead Data Scientist" -> title_points=1 ("lead" is a keyword)
- `test_keyword_case_insensitive`: title="SENIOR Developer" -> title_points=1
- Parametrize keywords that score 1: "senior", "principal", "staff", "lead", "manager", "architect", "devops", "platform", "infrastructure", "sre"
- `test_no_match_scores_0`: title="Junior Analyst" -> title_points=0
- `test_empty_title_scores_0`: title="" -> title_points=0

**class TestTechScoring:**
- `test_five_plus_keywords_scores_2`: description containing "python kubernetes terraform docker aws gcp" -> tech_points=2, matched list has 5+ items
- `test_two_to_four_keywords_scores_1`: description with "python kubernetes" only -> tech_points=1
- `test_one_keyword_scores_0`: description with only "python" -> tech_points=0
- `test_no_keywords_scores_0`: description="no matching technologies here" -> tech_points=0
- `test_tags_contribute`: tags=["python", "kubernetes", "terraform", "docker", "aws"], description="" -> tech_points=2 (tags are included in the search text)
- `test_tech_matched_list`: Verify `breakdown.tech_matched` contains exact matched keywords

**class TestLocationScoring:**
- Parametrize locations scoring 1: "Remote", "remote", "Anywhere", "Work from home", "Ontario, Canada", "Toronto, ON", "Canada"
- `test_onsite_scores_0`: location="San Francisco, CA" -> remote_points=0
- `test_empty_location_scores_0`: location="" -> remote_points=0

**class TestSalaryScoring:**
- `test_max_above_target_scores_1`: salary_max=250000 -> salary_points=1
- `test_min_above_target_scores_1`: salary_min=200000, salary_max=None -> salary_points=1 (use salary_min=200000 only)
- `test_max_exactly_target_scores_1`: salary_max=200000 -> salary_points=1
- `test_below_target_scores_0`: salary_max=150000 -> salary_points=0
- `test_no_salary_scores_0`: no salary fields set -> salary_points=0

**class TestOverallScoring:**
- `test_perfect_match_scores_5`: title="Principal Engineer", 5+ tech keywords, location="Remote", salary_max=250000 -> score=5
  - Raw: title(2) + tech(2) + remote(1) + salary(1) = 6, maps to 5
- `test_minimal_match_scores_1`: title="Intern", description="no match", location="office", no salary -> score=1
  - Raw: 0+0+0+0 = 0, maps to 1
- `test_score_3_boundary`: Build job with raw=3 exactly (e.g., title match=2, tech match=1, no remote, no salary -> raw=3) -> score=3
- `test_score_4_boundary`: Build job with raw=4 exactly -> score=4
- `test_score_2_boundary`: Build job with raw=2 exactly -> score=2

**class TestScoreBatch:**
- `test_batch_scores_all_jobs`: Create 3 jobs, call score_batch() -> all have non-None scores
- `test_batch_sets_status_scored`: After score_batch(), all jobs have status=JobStatus.SCORED
- `test_batch_sorts_descending`: Result list is sorted with highest score first

**class TestCustomWeights:**
- `test_zero_salary_weight_ignores_salary`: weights=ScoringWeights(salary=0.0), job with salary_max=300000 -> salary does NOT contribute to score. Compare against same job with default weights.
- `test_doubled_title_weight`: weights=ScoringWeights(title_match=4.0) -> title match has more influence. A job with title match but nothing else should score higher than with default weights.

**class TestScoreBreakdown (UNIT-04):**
- `test_breakdown_fields`: Verify ScoreBreakdown has title_points, tech_points, tech_matched, remote_points, salary_points, total
- `test_display_inline_format`: `ScoreBreakdown(title_points=2, tech_points=1, remote_points=1, salary_points=0, total=4).display_inline()` -> `"Title +2 | Tech +1 | Remote +1 | Salary +0 = 4"`
- `test_display_with_keywords`: Set tech_matched=["python", "kubernetes"], verify output includes `"(python, kubernetes)"`
- `test_to_dict_keys`: Verify `.to_dict()` returns dict with keys: title, tech, tech_matched, remote, salary, total
- `test_score_job_with_breakdown_returns_tuple`: Call `scorer.score_job_with_breakdown(job)` -> returns `(int, ScoreBreakdown)` and both agree on total
- `test_breakdown_matches_individual_factors`: For a known job, verify breakdown.title_points matches what `_title_score()` would return (test via the public API `score_job_with_breakdown`)
  </action>
  <verify>
Run: `uv run pytest tests/test_scorer.py -v --tb=short` -- all tests pass.
Run: `uv run pytest tests/test_scorer.py -v --tb=short 2>&1 | grep -c "PASSED"` -- expect 30+ passed tests.
Run: `uv run pytest tests/test_scorer.py --cov=scorer --cov-report=term-missing -q` -- verify meaningful scorer.py coverage.
  </verify>
  <done>tests/test_scorer.py covers: title scoring (exact match, keyword match, no match), tech scoring (threshold boundaries, tags contribution, matched keyword list), location scoring (remote variants, on-site), salary scoring (above/below/at target), overall score mapping (boundaries 1-5), batch scoring (in-place mutation, status, sort order), custom weights (zero out, double up), and score breakdown (display formats, to_dict, tuple return). All tests pass with explicit profile/weights (no get_settings()).</done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/test_scorer.py -v --tb=short` -- all tests pass
2. `uv run pytest tests/test_scorer.py -m unit -v` -- markers correct
3. `uv run pytest tests/test_scorer.py --cov=scorer --cov-report=term-missing -q` -- high coverage of scorer.py
4. `uv run pytest tests/test_smoke.py -v --tb=short` -- no regressions
5. Verify no test imports or calls `get_settings()` directly
</verification>

<success_criteria>
- tests/test_scorer.py tests all 4 scoring factors independently (title, tech, location, salary) with boundary cases
- Overall score mapping tested at each threshold boundary (1, 2, 3, 4, 5)
- score_batch() tested for in-place mutation, status setting, and sort order
- Custom weights tested (zero out a factor, double a factor)
- ScoreBreakdown display formats and to_dict verified
- All tests use explicit CandidateProfile and ScoringWeights (never get_settings())
- All tests pass with `uv run pytest tests/test_scorer.py -v`
- All tests marked @pytest.mark.unit
</success_criteria>

<output>
After completion, create `.planning/phases/10-unit-tests/10-02-SUMMARY.md`
</output>
