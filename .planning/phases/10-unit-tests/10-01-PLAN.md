---
phase: 10-unit-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test_models.py
  - tests/test_salary.py
autonomous: true

must_haves:
  truths:
    - "Invalid Pydantic model inputs (wrong platform, missing required fields, score out of range, salary_max < salary_min) are rejected with ValidationError"
    - "Valid Job, SearchQuery, and CandidateProfile instances construct without error and have correct field values"
    - "Job.dedup_key() normalizes company names by stripping Inc/LLC/Ltd suffixes, commas, lowercasing, and combines with lowered title"
    - "All JobStatus enum values are accessible and serialize correctly as strings"
    - "parse_salary() handles all 14 documented formats: Indeed range, hourly, Dice verbose, K-notation, CAD suffix, monthly, None/empty, unparseable, GBP/EUR, small-number heuristic"
    - "parse_salary_ints() handles RemoteOK quirk where salary_max=0 and min>0"
    - "NormalizedSalary.display produces compact format like $150K-$200K USD/yr"
  artifacts:
    - path: "tests/test_models.py"
      provides: "UNIT-01: Pydantic model validation tests for Job, SearchQuery, CandidateProfile, JobStatus"
      contains: "class TestJob"
    - path: "tests/test_salary.py"
      provides: "UNIT-02: Salary normalization tests for parse_salary and parse_salary_ints"
      contains: "test_parse_salary"
  key_links:
    - from: "tests/test_models.py"
      to: "models.py"
      via: "Direct import of Job, SearchQuery, CandidateProfile, JobStatus"
      pattern: "from models import"
    - from: "tests/test_salary.py"
      to: "salary.py"
      via: "Direct import of parse_salary, parse_salary_ints, NormalizedSalary"
      pattern: "from salary import"
---

<objective>
Write unit tests for Pydantic model validation (UNIT-01) and salary normalization (UNIT-02).

Purpose: These two modules are pure data validation and parsing with zero I/O -- the simplest unit test targets. Covering them first establishes baseline confidence in the data layer that scoring, dedup, and delta detection all depend on.

Output: tests/test_models.py and tests/test_salary.py with comprehensive parametrized tests.
</objective>

<execution_context>
@/Users/patrykattc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrykattc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-unit-tests/10-RESEARCH.md
@models.py
@salary.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tests/test_models.py for UNIT-01</name>
  <files>tests/test_models.py</files>
  <action>
Create comprehensive unit tests for all Pydantic models in `models.py`. Mark all tests with `@pytest.mark.unit`.

**class TestJobStatus:**
- `test_all_statuses_accessible`: Verify all 11 enum values exist and are accessible (DISCOVERED through GHOSTED)
- `test_status_string_values`: Verify each enum member's `.value` matches the expected snake_case string (e.g., `JobStatus.PHONE_SCREEN.value == "phone_screen"`)

**class TestJob:**
- `test_valid_minimal_job`: Construct `Job(platform="indeed", title="Engineer", company="ACME", url="https://example.com")` -- should succeed with defaults for optional fields
- `test_valid_full_job`: Construct with all fields populated -- salary, salary_min/max, tags, score, etc.
- `test_invalid_platform_rejected`: Use `pytest.raises(ValidationError)` for `platform="linkedin"` (not in Literal)
- `test_missing_required_fields`: Omit `title`, `company`, `url` individually -- each should raise ValidationError
- `test_score_lower_bound`: `score=0` should raise ValidationError (ge=1)
- `test_score_upper_bound`: `score=6` should raise ValidationError (le=5)
- `test_score_valid_range`: Parametrize scores 1-5, all should succeed
- `test_score_none_allowed`: `score=None` should be valid (default)
- `test_salary_max_gte_min_valid`: `salary_min=100000, salary_max=200000` should pass
- `test_salary_max_gte_min_equal`: `salary_min=150000, salary_max=150000` should pass
- `test_salary_max_lt_min_rejected`: `salary_min=200000, salary_max=100000` should raise ValidationError matching "salary_max must be >= salary_min"
- `test_salary_min_none_max_set`: `salary_min=None, salary_max=200000` should be valid (validator only checks when both are set)
- `test_default_values`: Verify defaults -- `id=""`, `location=""`, `status=JobStatus.DISCOVERED`, `salary_currency="USD"`, `easy_apply=False`, `tags=[]`, `company_aliases=[]`

**class TestDedupKey:**
- Parametrize `(company, title, expected_key)`:
  - `("Google Inc.", "Staff Engineer")` -> `"google::staff engineer"`
  - `("Google, Inc", "Staff Engineer")` -> `"google::staff engineer"`
  - `("GOOGLE LLC", "staff engineer")` -> `"google::staff engineer"`
  - `("Google Ltd", "Staff Engineer")` -> `"google::staff engineer"`
  - `("Google", "Staff Engineer")` -> `"google::staff engineer"`
  - `("  Google  ", "  Staff Engineer  ")` -> `"google::staff engineer"`
  - `("Acme Corp", "Developer")` -> `"acme corp::developer"` (no "corp" stripping in dedup_key -- only Inc/LLC/Ltd)

**class TestSearchQuery:**
- `test_valid_query`: Construct with `query="python"` -- defaults: platform="indeed", location="Remote", max_pages=5
- `test_max_pages_bounds`: `max_pages=0` and `max_pages=11` should raise ValidationError (ge=1, le=10)
- `test_valid_max_pages`: Parametrize 1-10, all should pass
- `test_invalid_platform`: `platform="glassdoor"` should raise ValidationError

**class TestCandidateProfile:**
- `test_default_values`: Construct `CandidateProfile()` with no args -- all str fields default to empty string, `desired_salary_usd=200_000`, `target_titles=[]`, `tech_keywords=[]`
- `test_custom_values`: Set `first_name="Patryk"`, `target_titles=["Staff Engineer"]`, `tech_keywords=["python", "kubernetes"]`
  </action>
  <verify>
Run: `uv run pytest tests/test_models.py -v --tb=short` -- all tests pass.
Run: `uv run pytest tests/test_models.py -v --tb=short 2>&1 | grep -c "PASSED"` -- expect 20+ passed tests.
  </verify>
  <done>tests/test_models.py has test classes covering: JobStatus enum values, Job validation (valid/invalid platform, required fields, score bounds, salary cross-field validator, defaults), dedup_key normalization (7+ parametrized cases), SearchQuery bounds, CandidateProfile defaults. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Create tests/test_salary.py for UNIT-02</name>
  <files>tests/test_salary.py</files>
  <action>
Create comprehensive parametrized tests for the salary parsing module. Mark all tests with `@pytest.mark.unit`.

**class TestParseSalary:**

Use `@pytest.mark.parametrize` with a large table covering all documented formats. Each case: `(input_text, expected_min, expected_max, expected_currency)`.

Parametrize table (14+ cases):
- `("$150,000 - $200,000", 150000, 200000, "USD")` -- Indeed range
- `("$85/hr", 85 * 2080, 85 * 2080, "USD")` -- hourly to annual (176800)
- `("$85 an hour", 85 * 2080, 85 * 2080, "USD")` -- hourly alt format
- `("USD 224,400.00 - 283,800.00 per year", 224400, 283800, "USD")` -- Dice verbose
- `("$175000", 175000, 175000, "USD")` -- single value
- `("$150K - $200K", 150000, 200000, "USD")` -- K-notation range
- `("$175K", 175000, 175000, "USD")` -- K-notation single
- `("150000-180000 CAD", 150000, 180000, "CAD")` -- CAD suffix
- `("$15,000/month", 15000 * 12, 15000 * 12, "USD")` -- monthly
- `("GBP 100,000", 100000, 100000, "GBP")` -- GBP currency
- `("EUR 120,000", 120000, 120000, "EUR")` -- EUR currency
- `(None, None, None, "USD")` -- None input
- `("", None, None, "USD")` -- empty string
- `("   ", None, None, "USD")` -- whitespace only
- `("Competitive", None, None, "USD")` -- unparseable (check raw is set)

**class TestParseSalarySmallNumbers:**

Test the sub-1000 heuristic separately for clarity:
- `("150", 150000, 150000, "USD")` -- small number treated as K
- `("1500", 1500, 1500, "USD")` -- above 1000, NOT treated as K
- `("85", 85000, 85000, "USD")` -- small number treated as K (no period marker)

**class TestParseSalaryInts:**

Parametrize for `parse_salary_ints(min_val, max_val, currency)`:
- `(200000, 300000, "USD")` -- normal range: min=200000, max=300000
- `(200000, 0, "USD")` -- RemoteOK quirk: max=0 -> effective_max=200000
- `(None, None, "USD")` -- both None -> NormalizedSalary with min=None, max=None
- `(0, 0, "USD")` -- both zero -> min=None, max=None (because `0 or None` = None)
- `(150000, 150000, "CAD")` -- same min/max, CAD currency

**class TestSalaryDisplay:**

Test the display format is correct:
- `parse_salary("$150,000 - $200,000").display` -> `"$150K-$200K USD/yr"`
- `parse_salary("$175000").display` -> `"$175K USD/yr"`
- `parse_salary("150000-180000 CAD").display` -> `"C$150K-C$180K CAD/yr"`
- `parse_salary(None).display` -> `""` (empty)
- `parse_salary_ints(200000, 300000).display` -> `"$200K-$300K USD/yr"`

**class TestSalaryRawPreserved:**

Verify the `raw` field is preserved:
- `parse_salary("$150K - $200K").raw` -> `"$150K - $200K"`
- `parse_salary(None).raw` -> `""` (empty for None input)

**Important implementation notes:**
- The `parse_salary` function with "Competitive" returns `NormalizedSalary(raw="Competitive")` with `min_annual=None` and `max_annual=None` but `raw` is set.
- For the sub-1000 heuristic: only applies when `multiplier == 1` (no hourly/monthly marker). So `"$85/hr"` gives hourly calculation, NOT the sub-1000 K-shorthand.
  </action>
  <verify>
Run: `uv run pytest tests/test_salary.py -v --tb=short` -- all tests pass.
Run: `uv run pytest tests/test_salary.py -v --tb=short 2>&1 | grep -c "PASSED"` -- expect 25+ passed tests.
  </verify>
  <done>tests/test_salary.py has parametrized test classes covering: all 14 documented salary formats, sub-1000 K-shorthand heuristic (both sides of threshold), parse_salary_ints with RemoteOK quirks, display format verification, raw field preservation. All tests pass.</done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/test_models.py tests/test_salary.py -v --tb=short` -- all tests pass
2. `uv run pytest tests/test_models.py tests/test_salary.py -m unit -v` -- markers are correct
3. `uv run pytest tests/test_models.py tests/test_salary.py --cov=models --cov=salary --cov-report=term-missing -q` -- coverage report shows meaningful coverage of both modules
4. `uv run pytest tests/test_smoke.py -v --tb=short` -- smoke tests still pass (no regressions)
</verification>

<success_criteria>
- tests/test_models.py covers all Pydantic model validation: Job (valid/invalid construction, field validators, cross-field validators, defaults), SearchQuery (bounds), CandidateProfile (defaults), JobStatus (enum), dedup_key (7+ normalization cases)
- tests/test_salary.py covers all 14 salary formats via parametrize, sub-1000 heuristic, parse_salary_ints with RemoteOK quirk, display format, raw preservation
- All tests pass with `uv run pytest tests/test_models.py tests/test_salary.py -v`
- All tests marked with `@pytest.mark.unit`
- No config file or network access needed (pure data validation)
</success_criteria>

<output>
After completion, create `.planning/phases/10-unit-tests/10-01-SUMMARY.md`
</output>
