---
phase: 11-database-integration-tests
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - tests/webapp/test_db.py
autonomous: true

must_haves:
  truths:
    - "FTS5 search returns relevant results for partial prefix matches (e.g., searching 'kube' finds 'kubernetes')"
    - "FTS5 search returns empty results (not errors) for queries with no matches"
    - "FTS5 search matches across title, company, and description columns"
    - "FTS5 index stays in sync after upsert -- re-upserting with a changed description makes the new text searchable and the old text unsearchable"
    - "FTS5 handles special characters without crashing or documents the known limitation"
    - "Activity log entries are automatically created on upsert_job() for new jobs with event_type='discovered'"
    - "Activity log entries are automatically created on update_job_status() with event_type='status_change' and correct old_value/new_value"
    - "Activity log entries are automatically created on update_job_notes() with event_type='note_added' and detail containing the notes text"
    - "Activity log entries include accurate timestamps and are ordered newest-first by get_activity_log()"
    - "Multiple status transitions on the same job produce multiple activity log entries tracking the full history"
  artifacts:
    - path: "tests/webapp/test_db.py"
      provides: "DB-02, DB-03: FTS5 search and activity log integration tests appended to existing file"
      contains: "class TestFts5Search"
  key_links:
    - from: "tests/webapp/test_db.py"
      to: "webapp/db.py"
      via: "get_jobs(search=...) for FTS5, log_activity/get_activity_log for activity log"
      pattern: "db_module.get_jobs.*search"
---

<objective>
Write integration tests for FTS5 full-text search (DB-02) and activity log automatic recording (DB-03).

Purpose: These tests verify the query-side and event-tracking behavior of webapp/db.py -- that FTS5 search returns relevant results with prefix matching and handles edge cases gracefully, and that activity log entries are automatically created on status transitions, notes updates, and new job discovery.

Output: TestFts5Search and TestActivityLog classes appended to tests/webapp/test_db.py.
</objective>

<execution_context>
@/Users/patrykattc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrykattc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-database-integration-tests/11-RESEARCH.md
@.planning/phases/11-database-integration-tests/11-01-SUMMARY.md
@webapp/db.py
@tests/conftest.py
@tests/webapp/test_db.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add FTS5 search tests (DB-02)</name>
  <files>tests/webapp/test_db.py</files>
  <action>
Append a new test class to the existing `tests/webapp/test_db.py` file.

**class TestFts5Search (DB-02):**

- `test_search_by_title_keyword`: Insert job with title "Staff Kubernetes Engineer". Search `get_jobs(search="kubernetes")`. Assert 1 result. Verify title matches.
- `test_search_by_company_keyword`: Insert 2 jobs -- one at "Google", one at "Microsoft". Search `get_jobs(search="google")`. Assert 1 result with company "Google".
- `test_search_by_description_keyword`: Insert job with description "Expert in terraform and cloud infrastructure". Search `get_jobs(search="terraform")`. Assert 1 result.
- `test_search_prefix_matching`: Insert job with description "kubernetes cluster management". Search `get_jobs(search="kube")`. Assert 1 result. (get_jobs adds `*` suffix for prefix matching when no FTS5 operators detected.)
- `test_search_multi_word_prefix`: Insert job with title "Senior Platform Engineer" and description "kubernetes and terraform expert". Search `get_jobs(search="senior kubernetes")`. Assert 1 result. (Both words get `*` suffix: `"senior* kubernetes*"`.)
- `test_search_no_match_returns_empty`: Insert job with title "Python Developer". Search `get_jobs(search="golang")`. Assert empty list (not error).
- `test_search_empty_string_returns_all`: Insert 2 jobs. Search `get_jobs(search="")`. Assert 2 results. (Empty search string is treated as no search filter.)
- `test_search_none_returns_all`: Insert 2 jobs. Search `get_jobs(search=None)`. Assert 2 results.
- `test_fts_sync_after_upsert_update`: Insert job with description "python developer". Verify `get_jobs(search="python")` returns 1. Re-upsert same dedup_key with longer description "java and cloud infrastructure engineer" (must be longer to trigger description update via LENGTH comparison). Verify `get_jobs(search="java")` returns 1. Verify `get_jobs(search="python")` returns 0 (old text no longer indexed). **NOTE:** The description update only occurs if the new description is LONGER than the existing one (see the ON CONFLICT clause in upsert_job). Use a short initial description and a longer replacement.
- `test_fts_with_combined_filters`: Insert 3 jobs -- 2 with "kubernetes" in description (one score=3, one score=5), 1 without. Search `get_jobs(search="kubernetes", score_min=4)`. Assert 1 result (score=5 job only).
- `test_search_special_chars_no_crash`: Test that searching with special characters either returns results or handles gracefully. Use `pytest.raises` if `OperationalError` is expected, or assert graceful empty result. Test strings: `"C++"`, `"node.js"`, `"@company"`. For each: wrap in try/except `sqlite3.OperationalError` -- if it raises, that is the known FTS5 limitation (document with a comment). If it does not raise, assert the result is a list.
- `test_fts_operator_passthrough`: Insert job with description "kubernetes AND terraform expert". Search `get_jobs(search='"kubernetes"')` (quoted -- FTS5 exact match operator). The function detects `"` as FTS5 operator and passes through without adding `*`. Assert result is a list (may be empty if FTS5 exact match differs from prefix).

**Important implementation notes:**
- The `_make_job_dict` helper from Task 1 of Plan 11-01 is already defined at module level -- reuse it.
- When testing FTS sync after upsert update, the new description MUST be longer than the old one for the ON CONFLICT clause to update it. E.g., old: "python developer" (16 chars), new: "java and cloud infrastructure engineer working on distributed systems" (68+ chars).
- FTS5 search uses `get_jobs(search=...)` which JOINs with `jobs_fts` via `MATCH`.
- For `test_search_special_chars_no_crash`, import `sqlite3` at the top of the file to catch `OperationalError`.
  </action>
  <verify>
Run: `uv run pytest tests/webapp/test_db.py::TestFts5Search -v --tb=short` -- all tests pass.
  </verify>
  <done>TestFts5Search covers: single-word title/company/description search, prefix matching (partial words), multi-word search, no-match returns empty, empty/None search returns all, FTS sync after description update via upsert, combined search+filter, special character handling, and FTS5 operator passthrough. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Add activity log tests (DB-03)</name>
  <files>tests/webapp/test_db.py</files>
  <action>
Append a new test class to the existing `tests/webapp/test_db.py` file.

**class TestActivityLog (DB-03):**

- `test_upsert_new_job_logs_discovered`: Insert a new job via `upsert_job()`. Call `get_activity_log(key)`. Assert exactly 1 entry. Verify `event_type == "discovered"` and `new_value == "indeed"` (the platform).
- `test_upsert_existing_job_no_duplicate_discovered`: Insert a job, then re-upsert same job. Call `get_activity_log(key)`. Assert still exactly 1 "discovered" entry (no duplicate).
- `test_status_change_logged`: Insert job. Call `update_job_status(key, "applied")`. Call `get_activity_log(key)`. Find the `status_change` entry. Verify `old_value == "discovered"` and `new_value == "applied"`.
- `test_multiple_status_changes_tracked`: Insert job. Transition through: discovered -> scored -> saved -> applied. Call `get_activity_log(key)`. Filter for `event_type == "status_change"`. Assert 3 status_change entries. Verify the chain: (discovered->scored), (scored->saved), (saved->applied).
- `test_notes_update_logged`: Insert job. Call `update_job_notes(key, "Great K8s role")`. Call `get_activity_log(key)`. Find the `note_added` entry. Verify `detail == "Great K8s role"`.
- `test_activity_log_has_timestamps`: Insert job. Update status. Call `get_activity_log(key)`. Verify every entry has a non-null `created_at` field.
- `test_activity_log_newest_first`: Insert job. Call `update_job_status(key, "scored")`, then `update_job_status(key, "applied")`. Call `get_activity_log(key)`. Assert the first entry (index 0) is the most recent event ("applied" status change), and the last entry is the oldest ("discovered").
- `test_activity_log_empty_for_nonexistent_key`: Call `get_activity_log("nonexistent::key")`. Assert empty list.
- `test_log_activity_direct`: Call `log_activity("test::key", "custom_event", old_value="old", new_value="new", detail="custom detail")` directly. Call `get_activity_log("test::key")`. Assert 1 entry with all fields matching.
- `test_full_lifecycle_activity_trail`: Insert job. Mark as scored, saved, applied. Add notes. Call `get_activity_log(key)`. Verify total entries == 5 (1 discovered + 3 status_change + 1 note_added). This tests that the activity log faithfully records every action on a job through its full lifecycle.

**Important implementation notes:**
- Remember that `upsert_job()` auto-logs a "discovered" event for NEW jobs. Every test that calls `upsert_job()` and then checks the activity log must account for this baseline entry.
- `get_activity_log()` returns entries in `ORDER BY created_at DESC` (newest first).
- For `test_multiple_status_changes_tracked`, call `update_job_status(key, "scored")`, then `update_job_status(key, "saved")`, then `update_job_status(key, "applied")`. This produces 3 status_change events with correct old->new chains.
  </action>
  <verify>
Run: `uv run pytest tests/webapp/test_db.py::TestActivityLog -v --tb=short` -- all tests pass.
Run: `uv run pytest tests/webapp/test_db.py -v --tb=short` -- all tests pass (40+ total across all classes).
  </verify>
  <done>TestActivityLog covers: automatic "discovered" event on new job insert, no duplicate discovered on re-upsert, status_change logging with old/new values, multi-step status chain tracking, note_added logging with detail, timestamp presence, newest-first ordering, empty log for nonexistent key, direct log_activity, and full lifecycle trail (5 events). All tests pass.</done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/webapp/test_db.py -v --tb=short` -- all tests pass (40+ tests across all classes)
2. `uv run pytest tests/webapp/test_db.py -m integration -v` -- all tests are correctly marked as integration
3. `uv run pytest tests/webapp/test_db.py --cov=webapp/db --cov-report=term-missing -q` -- coverage report shows high coverage of webapp/db.py (target 80%+)
4. `uv run pytest tests/ -v --tb=short -q` -- all existing tests still pass (no regressions)
</verification>

<success_criteria>
- TestFts5Search covers: title/company/description keyword search, prefix matching, multi-word, no-match empty result, empty/None returns all, FTS sync after upsert update, combined search+filter, special character handling, FTS5 operator passthrough
- TestActivityLog covers: auto-discovered event, no duplicate on re-upsert, status_change with old/new, multi-step chain, note_added with detail, timestamps, newest-first ordering, empty for nonexistent, direct log_activity, full lifecycle trail
- All tests pass with `uv run pytest tests/webapp/test_db.py -v`
- All tests marked with `@pytest.mark.integration`
- Combined with Plan 11-01 tests, total test count is 40+ across 7 test classes
- webapp/db.py coverage reaches 80%+ for the functions under test
</success_criteria>

<output>
After completion, create `.planning/phases/11-database-integration-tests/11-02-SUMMARY.md`
</output>
