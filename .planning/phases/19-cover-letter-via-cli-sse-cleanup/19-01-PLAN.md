---
phase: 19-cover-letter-via-cli-sse-cleanup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - webapp/app.py
  - webapp/templates/partials/cover_letter_status.html
  - webapp/templates/partials/cover_letter_result.html
  - webapp/templates/job_detail.html
  - tests/webapp/test_cover_letter_sse.py
autonomous: true

must_haves:
  truths:
    - "POST /jobs/{key}/cover-letter returns an SSE-connect HTML snippet immediately (not blocking for 10-15s)"
    - "GET /jobs/{key}/cover-letter/stream yields progress, done, and error events via SSE"
    - "Cover letter pipeline runs as a background asyncio.Task emitting stage events (extracting, generating, rendering)"
    - "generate_cover_letter() internally calls claude_cli.run() which launches a CLI subprocess -- this was established in Phase 16-02 and is preserved here (COV-01)"
    - "PDF is rendered, version is saved, and activity is logged -- same as before (COV-03)"
    - "If the SSE connection closes (user navigates away), the background task is cancelled and the session is cleaned up"
    - "Double-click on Generate Cover Letter returns 'already in progress' instead of starting a second pipeline"
    - "The #resume-spinner div is removed from job_detail.html since both AI tool buttons now use SSE"
  artifacts:
    - path: "webapp/app.py"
      provides: "SSE-backed cover_letter_endpoint + cover_letter_stream + _run_cover_letter background task"
      contains: "_cover_sessions"
    - path: "webapp/templates/partials/cover_letter_status.html"
      provides: "SSE event rendering for progress/done/error states with emerald-500 spinner"
    - path: "webapp/templates/partials/cover_letter_result.html"
      provides: "Cover letter success result with download link and collapsible preview"
    - path: "webapp/templates/job_detail.html"
      provides: "Updated Cover Letter button with hx-disabled-elt, no hx-indicator, no #resume-spinner div"
    - path: "tests/webapp/test_cover_letter_sse.py"
      provides: "6 integration tests for SSE cover letter endpoints and background task"
  key_links:
    - from: "webapp/app.py::cover_letter_endpoint"
      to: "webapp/app.py::_run_cover_letter"
      via: "asyncio.create_task + asyncio.Queue"
      pattern: "_cover_sessions\\[dedup_key\\]"
    - from: "webapp/app.py::cover_letter_stream"
      to: "webapp/templates/partials/cover_letter_status.html"
      via: "templates.get_template render per event"
      pattern: "cover_letter_status\\.html"
    - from: "webapp/app.py::_run_cover_letter"
      to: "resume_ai/cover_letter.py::generate_cover_letter"
      via: "await generate_cover_letter()"
      pattern: "await generate_cover_letter"
    - from: "webapp/app.py::_run_cover_letter"
      to: "resume_ai/renderer.py::render_cover_letter_pdf"
      via: "asyncio.to_thread (blocking WeasyPrint call)"
      pattern: "asyncio\\.to_thread.*render_cover_letter_pdf"
---

<objective>
Convert the cover letter endpoint from a synchronous request-response pattern to SSE-backed streaming with real-time progress events through three pipeline stages, replicating the Phase 18 resume tailoring SSE pattern.

Purpose: Users currently see a frozen spinner for 10-15 seconds during cover letter generation. After this plan, they see live progress through each stage (extracting, generating, rendering), matching the SSE pattern already working for resume tailoring.

Output: Modified webapp/app.py with SSE endpoints, new cover_letter_status.html and cover_letter_result.html partials, updated job_detail.html button wiring, removal of #resume-spinner div, and 6 integration tests.
</objective>

<execution_context>
@/Users/patrykattc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrykattc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-cover-letter-via-cli-sse-cleanup/19-RESEARCH.md
@.planning/phases/18-resume-tailoring-via-cli-sse/18-01-SUMMARY.md
@webapp/app.py
@webapp/templates/job_detail.html
@webapp/templates/partials/resume_tailor_status.html
@resume_ai/cover_letter.py
@resume_ai/renderer.py
@resume_ai/tracker.py
@resume_ai/extractor.py
@tests/webapp/test_resume_sse.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build SSE cover letter pipeline and endpoints</name>
  <files>webapp/app.py, webapp/templates/partials/cover_letter_status.html, webapp/templates/partials/cover_letter_result.html, webapp/templates/job_detail.html</files>
  <action>
  This task replicates the Phase 18 resume tailoring SSE pattern for cover letters. Follow the exact same structure as `_run_resume_tailor`, `tailor_resume_endpoint`, and `resume_tailor_stream` -- but adapted for the simpler 3-stage cover letter pipeline (no anti-fabrication validation stage).

  **In `webapp/app.py`:**

  1. Add module-level session tracking dicts for cover letter (place them right before the existing `cover_letter_endpoint` function, after the `resume_tailor_stream` endpoint):

  ```python
  _cover_sessions: dict[str, asyncio.Queue] = {}
  _cover_tasks: dict[str, asyncio.Task] = {}
  ```

  2. Create the `_run_cover_letter` background task function (place it right after the session dicts). This follows the same structure as `_run_resume_tailor` but with 3 stages instead of 4 (no validation stage). Key implementation details:

  - Accept parameters: `dedup_key: str, job: dict, resume_path: str, queue: asyncio.Queue`
  - Use lazy imports inside the function for all resume_ai modules (same pattern as `_run_resume_tailor`)
  - Define an inner `_emit(event_type, message, html="")` helper that calls `queue.put_nowait({"type": event_type, "message": message, "html": html})`
  - Run 3 stages with progress events between them:
    - Stage 1 "extracting": `resume_text = await asyncio.to_thread(extract_resume_text, resume_path)` (sync function, wrap in to_thread)
    - Stage 2 "generating": `letter = await generate_cover_letter(resume_text=..., job_description=..., job_title=..., company_name=...)` (already async -- internally calls `claude_cli.run()` which satisfies COV-01)
    - Stage 3 "rendering": Build output_path using the same slug logic as the current endpoint (`company_slug = job["company"].replace(" ", "_")[:30]`, filename = `Patryk_Golabek_CoverLetter_{company_slug}_{date.today().isoformat()}.pdf`). Then `await asyncio.to_thread(render_cover_letter_pdf, letter, "Patryk Golabek", "pgolabek@gmail.com", "416-708-9839", output_path)` (CPU-bound WeasyPrint -- MUST use to_thread). After PDF, call `save_resume_version(...)` and `db.log_activity(...)` (both fast sync, ok inline)
  - After stage 3, build the final result HTML by rendering `partials/cover_letter_result.html` via `templates.get_template("partials/cover_letter_result.html").render(...)` with context: `download_url=f"/resumes/tailored/{filename}"`, `filename=filename`, `letter_preview=format_cover_letter_as_text(letter, "Patryk Golabek")`
  - Emit `_emit("done", "Cover letter generated successfully", html=result_html)`
  - Catch `asyncio.CancelledError`: emit `_emit("done", "Generation cancelled")` and re-raise
  - Catch `Exception as exc`: `logger.exception(...)`, emit `_emit("error", f"Cover letter generation failed: {exc}")`, then emit `_emit("done", "")`

  3. **Replace** the existing `cover_letter_endpoint` function (currently at line ~419). The new version:

  - Keep the same decorator and function signature: `@app.post("/jobs/{dedup_key:path}/cover-letter", response_class=HTMLResponse)` / `async def cover_letter_endpoint(request: Request, dedup_key: str)`
  - Job lookup: `job = db.get_job(dedup_key)`, return 404 if not found (same as now)
  - Session dedup check: if `dedup_key in _cover_sessions`, return `HTMLResponse('<div class="text-sm text-amber-700 bg-amber-50 border border-amber-300 px-4 py-3 rounded">Cover letter generation already in progress...</div>')`
  - Resolve resume path (same pattern as current code -- try config, fallback to DEFAULT_RESUME_PATH)
  - Create queue: `queue = asyncio.Queue()`
  - Store session: `_cover_sessions[dedup_key] = queue`
  - Start background task: `task = asyncio.create_task(_run_cover_letter(dedup_key, job, resume_path, queue))`
  - Store task: `_cover_tasks[dedup_key] = task`
  - Return HTML with SSE connection using **emerald-500** spinner (matching the emerald-600 button):
    ```python
    encoded_key = urllib.parse.quote(dedup_key, safe="")
    return HTMLResponse(
        f'<div hx-ext="sse"'
        f' sse-connect="/jobs/{encoded_key}/cover-letter/stream"'
        f' sse-swap="progress"'
        f' sse-close="done">'
        f'  <div class="flex items-center gap-2 py-2">'
        f'    <div class="animate-spin h-4 w-4 border-2 border-emerald-500'
        f' border-t-transparent rounded-full"></div>'
        f'    <span class="text-sm text-gray-500">Starting cover letter generation...</span>'
        f'  </div>'
        f'</div>'
    )
    ```

  4. Add the SSE stream endpoint right after the trigger endpoint. Follow the exact pattern of `resume_tailor_stream`:

  ```python
  @app.get("/jobs/{dedup_key:path}/cover-letter/stream")
  async def cover_letter_stream(request: Request, dedup_key: str):
      """SSE endpoint streaming real-time cover letter generation progress."""
      from sse_starlette import EventSourceResponse

      queue = _cover_sessions.get(dedup_key)
      if queue is None:
          return HTMLResponse(
              "<p class='text-red-600 text-sm'>No active cover letter session</p>",
              status_code=404,
          )

      async def event_generator():
          try:
              while True:
                  if await request.is_disconnected():
                      break
                  try:
                      event = await asyncio.wait_for(queue.get(), timeout=15)
                      event_type = event.get("type", "progress")
                      html = templates.get_template(
                          "partials/cover_letter_status.html"
                      ).render(event=event, dedup_key=dedup_key)
                      yield {"event": event_type, "data": html}
                      if event_type == "done":
                          break
                  except TimeoutError:
                      yield {"event": "ping", "data": ""}
          except asyncio.CancelledError:
              pass
          finally:
              _cover_sessions.pop(dedup_key, None)
              task = _cover_tasks.pop(dedup_key, None)
              if task and not task.done():
                  task.cancel()

      return EventSourceResponse(event_generator())
  ```

  NOTE: The stream endpoint MUST be registered BEFORE the catch-all `GET /jobs/{dedup_key:path}` route. Place it alongside the cover letter trigger endpoint in the existing section, after the resume tailoring endpoints but before the ai-rescore endpoint and the catch-all GET route.

  **In `webapp/templates/partials/cover_letter_status.html`:**

  Create a new partial template for SSE events. Same structure as `resume_tailor_status.html` but with emerald-500 spinner color:

  ```html
  {# Cover letter SSE status partial -- rendered per event and swapped via sse-swap="progress" #}

  {% if event.type == "progress" %}
  <div class="flex items-center gap-2 py-2">
      <div class="animate-spin h-4 w-4 border-2 border-emerald-500 border-t-transparent rounded-full"></div>
      <span class="text-sm text-gray-700">{{ event.message }}</span>
  </div>

  {% elif event.type == "error" %}
  <div class="bg-red-50 border border-red-400 text-red-800 px-4 py-3 rounded">
      <p class="text-sm font-medium">Error</p>
      <p class="text-sm">{{ event.message }}</p>
  </div>

  {% elif event.type == "done" %}
  {% if event.html %}
  {{ event.html | safe }}
  {% elif event.message %}
  <div class="bg-gray-50 border border-gray-300 text-gray-700 px-4 py-3 rounded">
      <p class="text-sm">{{ event.message }}</p>
  </div>
  {% endif %}

  {% else %}
  <div class="py-2">
      <span class="text-sm text-gray-500">{{ event.message }}</span>
  </div>
  {% endif %}
  ```

  **In `webapp/templates/partials/cover_letter_result.html`:**

  Create a new partial template for the cover letter done event result (embedded in the "done" event HTML via pre-rendering in the background task):

  ```html
  {# Cover letter result: success message, download link, and text preview #}

  <div class="bg-green-50 border border-green-400 text-green-800 px-4 py-3 rounded mb-4">
      <p class="text-sm font-medium">Cover letter generated successfully</p>
  </div>

  <a href="{{ download_url }}"
     class="inline-block bg-emerald-600 text-white px-4 py-2 rounded text-sm hover:bg-emerald-700 mb-4"
     download>Download Cover Letter ({{ filename }})</a>

  {% if letter_preview %}
  <details class="mt-4 border rounded">
      <summary class="px-4 py-2 bg-gray-50 text-sm font-medium text-gray-700 cursor-pointer">
          Preview Cover Letter
      </summary>
      <div class="px-4 py-3 text-sm text-gray-700 whitespace-pre-line">{{ letter_preview }}</div>
  </details>
  {% endif %}
  ```

  **In `webapp/templates/job_detail.html`:**

  Update the "AI Resume Tools" sidebar card:

  1. Update the Cover Letter button: remove `hx-indicator="#resume-spinner"`, add `hx-disabled-elt="this"`, add disabled styling classes (`disabled:opacity-50 disabled:cursor-not-allowed`):
     ```html
     <button hx-post="/jobs/{{ job.dedup_key | urlencode }}/cover-letter"
             hx-target="#resume-ai-result"
             hx-swap="innerHTML"
             hx-disabled-elt="this"
             class="w-full bg-emerald-600 text-white px-4 py-2 rounded text-sm hover:bg-emerald-700 disabled:opacity-50 disabled:cursor-not-allowed mb-2">
         Generate Cover Letter
     </button>
     ```

  2. Remove the `#resume-spinner` div entirely (the 3-line block: `<div id="resume-spinner" class="htmx-indicator ...">...</div>`). Both AI tool buttons now use SSE for progress display. Verify first via grep that nothing else references `resume-spinner` in the codebase.
  </action>
  <verify>
  1. `uv run ruff check webapp/app.py webapp/templates/` -- no lint errors
  2. `uv run ruff format --check webapp/app.py` -- formatting OK
  3. Grep for `_cover_sessions` in webapp/app.py -- should appear in 3+ locations (declaration, trigger, stream, background task)
  4. Grep for `cover_letter_status.html` -- should appear in webapp/app.py (stream endpoint) and exist as a file
  5. Grep for `cover_letter_result.html` -- should appear in webapp/app.py (background task) and exist as a file
  6. Verify the new SSE stream endpoint is registered BEFORE the catch-all GET route by checking line order in app.py
  7. Grep for `resume-spinner` -- should return ZERO results (removed from job_detail.html, no other references)
  8. `uv run pytest tests/ -x --timeout=30` -- full test suite passes (existing tests should not break since the endpoint contract is the same POST path, but now returns different HTML)
  </verify>
  <done>
  POST /jobs/{key}/cover-letter returns an SSE-connect div immediately with emerald-500 spinner. GET /jobs/{key}/cover-letter/stream yields SSE events. The background task runs all 3 pipeline stages with progress events. PDF rendering, version tracking, and activity logging all still work. Session cleanup happens on disconnect. Double-click protection via session check. #resume-spinner div removed. Cover letter button has disabled styling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for SSE cover letter pipeline</name>
  <files>tests/webapp/test_cover_letter_sse.py</files>
  <action>
  Create a new test file `tests/webapp/test_cover_letter_sse.py` for the SSE cover letter endpoints. Follow the exact pattern of `tests/webapp/test_resume_sse.py` but adapted for the cover letter 3-stage pipeline.

  **Test helpers (same pattern as test_resume_sse.py):**
  - `_make_job_dict(company, title, **kwargs)` -- same helper
  - `_compute_dedup_key(company, title)` -- same helper
  - `_make_cover_letter()` -- build a minimal `CoverLetter` model for mocking. Import from `resume_ai.models`. Use realistic but minimal field values: greeting="Dear Hiring Manager,", opening="I am excited...", body_paragraphs=["Experience paragraph"], closing="Thank you for considering...", sign_off="Sincerely"

  **Tests to write (mark all with `@pytest.mark.integration` on the class):**

  1. **test_cover_letter_returns_sse_connect_html** -- POST to cover-letter endpoint with a valid job returns 200 and HTML containing `sse-connect` and `cover-letter/stream`. Use `mock_claude_cli` fixture with a mock `CoverLetter` response. Mock `extract_resume_text` to return a fixed string (avoid needing a real PDF), and mock `render_cover_letter_pdf` and `save_resume_version` (avoid WeasyPrint). Verify response contains `sse-connect`. Clean up session state after.
     - Patch at source modules: `resume_ai.extractor.extract_resume_text`, `resume_ai.renderer.render_cover_letter_pdf`, `resume_ai.tracker.save_resume_version`

  2. **test_cover_letter_404_for_missing_job** -- POST with a nonexistent dedup_key returns 404. No mocking needed.

  3. **test_cover_letter_already_in_progress** -- Manually insert a queue into `_cover_sessions` dict before calling POST. Verify the response contains "already in progress". Clean up the dict after.

  4. **test_stream_404_for_no_session** -- GET /jobs/{key}/cover-letter/stream without an active session returns 404.

  5. **test_background_task_emits_stage_events** -- This tests `_run_cover_letter` directly (not through HTTP). Create a queue, mock all resume_ai functions (`extract_resume_text`, `generate_cover_letter`, `format_cover_letter_as_text`, `render_cover_letter_pdf`, `save_resume_version`) and `db.log_activity`. Call `_run_cover_letter` as an awaitable (not as a task). Collect all events from the queue. Assert:
     - At least 3 "progress" events were emitted (one per stage)
     - Progress messages contain stage keywords: "Extracting", "Generating", "Rendering"
     - The last event type is "done"
     - The "done" event has non-empty "html" content

  6. **test_background_task_emits_error_on_failure** -- Same setup but mock `generate_cover_letter` to raise `RuntimeError("LLM call failed")`. Assert the queue contains an "error" event followed by a "done" event.

  **Important test patterns (from Phase 18 lessons):**
  - Use `mock_claude_cli` fixture for any test that involves the actual endpoint (tests 1, 2, 3 trigger endpoint code paths that may import resume_ai modules)
  - For tests 5 and 6, patch at source module paths (`resume_ai.extractor.extract_resume_text`, `resume_ai.cover_letter.generate_cover_letter`, etc.) since `_run_cover_letter` uses lazy imports
  - All tests with `_run_cover_letter` are `async` -- use `@pytest.mark.asyncio`
  - Import `_cover_sessions` from `webapp.app` to manipulate session state in test 3
  - Import `_run_cover_letter` from `webapp.app` for direct testing in tests 5-6
  - After tests that manipulate `_cover_sessions`, clean up via `_cover_sessions.pop(key, None)` in a finally block
  </action>
  <verify>
  1. `uv run pytest tests/webapp/test_cover_letter_sse.py -v` -- all 6 tests pass
  2. `uv run pytest tests/ -x --timeout=30` -- full test suite passes with no regressions
  3. `uv run ruff check tests/webapp/test_cover_letter_sse.py` -- no lint errors
  </verify>
  <done>
  6 tests verify: SSE-connect HTML returned by trigger, 404 handling, double-click protection, stream 404 without session, background task stage events (3 stages + done), error propagation. Full test suite passes with no regressions. Requirements COV-01, COV-02, COV-03 verified.
  </done>
</task>

</tasks>

<verification>
1. `uv run ruff check .` -- zero lint errors across entire codebase
2. `uv run ruff format --check .` -- formatting consistent
3. `uv run pytest tests/ -x --timeout=30` -- full suite passes
4. Verify `webapp/app.py` contains `_cover_sessions`, `_cover_tasks`, `_run_cover_letter`, `cover_letter_stream`
5. Verify `webapp/templates/partials/cover_letter_status.html` exists and handles progress/done/error
6. Verify `webapp/templates/partials/cover_letter_result.html` exists with download link and preview
7. Verify `webapp/templates/job_detail.html` Cover Letter button no longer has `hx-indicator` and has `hx-disabled-elt`
8. Grep for `resume-spinner` returns zero results
9. Grep for `sse-connect.*cover-letter/stream` in webapp/app.py -- confirms SSE wiring
</verification>

<success_criteria>
- POST /jobs/{key}/cover-letter returns SSE-connect HTML immediately (not blocking)
- SSE stream yields 3+ progress events (extracting, generating, rendering) plus done
- PDF rendering, version tracking, and activity logging all still work
- Session cleanup on disconnect (no zombie tasks)
- Double-click protection returns "already in progress"
- #resume-spinner div fully removed from job_detail.html
- 6+ new tests pass, zero regressions in full suite
- Requirements COV-01, COV-02, COV-03 addressed
</success_criteria>

<output>
After completion, create `.planning/phases/19-cover-letter-via-cli-sse-cleanup/19-01-SUMMARY.md`
</output>
