---
phase: 08-one-click-apply
plan: 03
type: execute
wave: 3
depends_on: ["08-01", "08-02"]
files_modified:
  - webapp/app.py
  - webapp/templates/base.html
  - webapp/templates/job_detail.html
  - webapp/templates/partials/apply_status.html
autonomous: true

must_haves:
  truths:
    - "Clicking Apply on a job detail page triggers a POST that starts the apply engine in a background thread"
    - "Real-time status updates stream to the browser via SSE using sse-starlette + htmx-ext-sse"
    - "User sees progress messages as the apply flow proceeds (launching browser, logging in, filling form, etc.)"
    - "Duplicate detection warns the user before starting if the job has already been applied to"
    - "Apply actions are logged in the job's activity timeline"
    - "User can select apply mode (semi-auto, full-auto, easy-apply-only) from a dropdown before clicking Apply"
    - "A Confirm/Cancel button appears when the engine reaches awaiting_confirm state"
  artifacts:
    - path: "webapp/app.py"
      provides: "POST /jobs/{key}/apply endpoint, GET /jobs/{key}/apply/stream SSE endpoint, POST /jobs/{key}/apply/confirm endpoint"
      contains: "EventSourceResponse"
    - path: "webapp/templates/base.html"
      provides: "htmx SSE extension script tag"
      contains: "htmx-ext-sse"
    - path: "webapp/templates/job_detail.html"
      provides: "Apply section with mode selector, apply button, and SSE status container"
      contains: "apply-section"
    - path: "webapp/templates/partials/apply_status.html"
      provides: "SSE-swapped progress partial with status message, spinner, and confirm button"
      contains: "apply-status"
  key_links:
    - from: "webapp/app.py"
      to: "apply_engine/engine.py"
      via: "ApplyEngine singleton"
      pattern: "from apply_engine.engine import ApplyEngine"
    - from: "webapp/app.py"
      to: "apply_engine/dedup.py"
      via: "pre-apply duplicate check"
      pattern: "from apply_engine.dedup import is_already_applied"
    - from: "webapp/templates/job_detail.html"
      to: "webapp/app.py"
      via: "hx-post to /jobs/{key}/apply"
      pattern: "hx-post.*apply"
    - from: "webapp/templates/job_detail.html"
      to: "webapp/app.py"
      via: "sse-connect to /jobs/{key}/apply/stream"
      pattern: "sse-connect"
---

<objective>
Wire the apply engine to the web dashboard via SSE endpoints and htmx. Install sse-starlette, add the htmx SSE extension, create the apply trigger and stream endpoints, and build the apply UI on the job detail page with mode selection, real-time progress, and confirmation buttons.

Purpose: This is the user-facing integration -- transforming the CLI-only apply flow into a dashboard-driven experience with real-time feedback.
Output: Working one-click apply flow from the dashboard with SSE streaming, mode selection, and confirmation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-one-click-apply/08-RESEARCH.md
@.planning/phases/08-one-click-apply/08-01-SUMMARY.md
@.planning/phases/08-one-click-apply/08-02-SUMMARY.md
@webapp/app.py
@webapp/templates/base.html
@webapp/templates/job_detail.html
@apply_engine/engine.py
@apply_engine/config.py
@apply_engine/events.py
@apply_engine/dedup.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install sse-starlette and add SSE + apply endpoints to webapp</name>
  <files>webapp/app.py</files>
  <action>
**Install dependency:**
Run `pip install sse-starlette` (add to project dependencies).

**webapp/app.py -- Add apply endpoints:**

All apply endpoints MUST be registered BEFORE the catch-all `@app.get("/jobs/{dedup_key:path}")` route (same pattern as the resume AI endpoints). Place them in a new section between the resume AI endpoints and the catch-all job_detail route.

1. **Module-level singleton:**
```python
# Lazy-init apply engine (avoid import errors if playwright not installed)
_apply_engine: ApplyEngine | None = None

def _get_apply_engine() -> ApplyEngine:
    global _apply_engine
    if _apply_engine is None:
        from apply_engine.engine import ApplyEngine
        _apply_engine = ApplyEngine()
    return _apply_engine
```

2. **POST /jobs/{dedup_key:path}/apply** -- Trigger apply flow:
   - Read `mode` from Form data (default to settings.apply.default_mode)
   - Check duplicate via `is_already_applied(dedup_key)` -- if already applied, return HTML warning with status and date
   - Get job from db.get_job(dedup_key) -- 404 if not found
   - Create an `asyncio.Queue()` for this session
   - Create a background task via `asyncio.create_task(_run_apply(job, mode, queue))`
   - Return HTML that establishes the SSE connection:
     ```html
     <div hx-ext="sse"
          sse-connect="/jobs/{dedup_key}/apply/stream"
          sse-swap="progress"
          sse-close="done">
       <div id="apply-live-status">
         <p class="text-sm text-gray-500">Connecting to apply engine...</p>
       </div>
     </div>
     ```
   - Store the queue reference so the SSE endpoint can access it (use `_get_apply_engine()._sessions`)

3. **Async helper `_run_apply`:**
```python
async def _run_apply(job: dict, mode: str, queue: asyncio.Queue):
    engine = _get_apply_engine()
    try:
        await engine.apply(job, mode, queue)
    except Exception as exc:
        from apply_engine.events import ApplyEvent, ApplyEventType
        await queue.put(ApplyEvent(type=ApplyEventType.ERROR, message=str(exc)).model_dump())
        await queue.put(ApplyEvent(type=ApplyEventType.DONE, message="Apply failed").model_dump())
```

4. **GET /jobs/{dedup_key:path}/apply/stream** -- SSE endpoint:
   - Import `from sse_starlette import EventSourceResponse`
   - Get the queue from `_get_apply_engine().get_session_queue(dedup_key)`
   - If no active session, return 404
   - Create async generator that drains the queue:
     ```python
     async def event_generator():
         try:
             while True:
                 if await request.is_disconnected():
                     break
                 try:
                     event = await asyncio.wait_for(queue.get(), timeout=15)
                     event_type = event.get("type", "progress")
                     # Render the event HTML using the apply_status partial
                     html = templates.get_template("partials/apply_status.html").render(
                         event=event, dedup_key=dedup_key
                     )
                     yield {"event": event_type, "data": html}
                     if event_type == "done":
                         break
                 except asyncio.TimeoutError:
                     yield {"event": "ping", "data": ""}
         except asyncio.CancelledError:
             pass
     ```
   - Return `EventSourceResponse(event_generator())`

5. **POST /jobs/{dedup_key:path}/apply/confirm** -- Confirm apply:
   - Call `_get_apply_engine().confirm(dedup_key)`
   - Return HTML: `<p class="text-sm text-green-600">Confirmed -- submitting application...</p>`

6. **POST /jobs/{dedup_key:path}/apply/cancel** -- Cancel apply:
   - Call `_get_apply_engine().cancel(dedup_key)`
   - Return HTML: `<p class="text-sm text-yellow-600">Apply cancelled.</p>`

**Important:** Use lazy imports for apply_engine modules (same pattern as resume_ai -- `from apply_engine.engine import ApplyEngine` inside the function, not at module level) to avoid startup failure when dependencies aren't installed.
  </action>
  <verify>
1. `python -c "from sse_starlette import EventSourceResponse; print('sse-starlette OK')"` succeeds
2. `python -c "from webapp.app import app; routes = [r.path for r in app.routes]; print('/jobs/{dedup_key:path}/apply' in str(routes))"` -- verify apply routes are registered (may need to check differently since FastAPI uses APIRoute)
3. `python -c "from webapp.app import _get_apply_engine; e = _get_apply_engine(); print(type(e).__name__)"` prints "ApplyEngine"
  </verify>
  <done>
POST /jobs/{key}/apply triggers the engine, GET /jobs/{key}/apply/stream returns SSE EventSourceResponse, POST /jobs/{key}/apply/confirm and /cancel handle human-in-the-loop. sse-starlette installed. All endpoints registered before the catch-all route.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add htmx SSE extension to base.html and apply UI to job_detail.html</name>
  <files>
    webapp/templates/base.html
    webapp/templates/job_detail.html
  </files>
  <action>
**webapp/templates/base.html:**
- Add the htmx SSE extension script tag after the main htmx script:
  ```html
  <script src="https://unpkg.com/htmx-ext-sse@2.2.4/sse.js"></script>
  ```
  Place it right after `<script src="https://unpkg.com/htmx.org@2.0.4"></script>`

**webapp/templates/job_detail.html:**
Add a new "Apply" section in the sidebar, positioned between the "AI Resume Tools" section and the "Resume Versions" section:

```html
<!-- Apply -->
<div class="bg-white rounded-lg shadow-sm border p-6">
    <h2 class="text-lg font-semibold text-gray-900 mb-3">Apply</h2>

    <!-- Mode selector -->
    <label class="block text-xs text-gray-500 mb-1">Apply Mode</label>
    <select id="apply-mode" class="border rounded px-3 py-1.5 text-sm mb-3 w-full">
        <option value="semi_auto" selected>Semi-Auto (fill + review)</option>
        <option value="full_auto">Full Auto (fill + confirm + submit)</option>
        <option value="easy_apply_only">Easy Apply Only</option>
    </select>

    <!-- Apply button -->
    <button hx-post="/jobs/{{ job.dedup_key | urlencode }}/apply"
            hx-vals='js:{"mode": document.getElementById("apply-mode").value}'
            hx-target="#apply-status"
            hx-swap="innerHTML"
            hx-indicator="#apply-spinner"
            id="apply-btn"
            class="w-full bg-purple-600 text-white px-4 py-2 rounded text-sm
                   hover:bg-purple-700 disabled:opacity-50 disabled:cursor-not-allowed"
            {% if job.status in ['applied', 'phone_screen', 'technical', 'final_interview', 'offer'] %}
            disabled
            title="Already applied"
            {% endif %}>
        {% if job.status in ['applied', 'phone_screen', 'technical', 'final_interview', 'offer'] %}
        Already Applied
        {% else %}
        Apply Now
        {% endif %}
    </button>

    <!-- Quick info about what will happen -->
    <p class="text-xs text-gray-400 mt-2">
        {% if job.easy_apply %}
        Easy Apply available via {{ job.platform | title }}
        {% elif job.apply_url %}
        External application ({{ job.apply_url | truncate(40) }})
        {% else %}
        Apply via {{ job.platform | title }}
        {% endif %}
    </p>

    <!-- Loading spinner (shown during POST) -->
    <div id="apply-spinner" class="htmx-indicator text-center py-2">
        <span class="text-sm text-gray-500">Starting apply engine...</span>
    </div>

    <!-- SSE status container (replaced by POST response, then SSE updates) -->
    <div id="apply-status" class="mt-3"></div>
</div>
```

Note: The `| truncate(40)` Jinja2 filter may not be available by default. If not, use `[:40]` slice or omit truncation. Check if Jinja2 has the truncate filter available.

The apply button should be disabled with "Already Applied" text when the job's status indicates it's already been applied to (applied, phone_screen, technical, final_interview, offer).
  </action>
  <verify>
1. Verify base.html has SSE extension: `grep "htmx-ext-sse" /Users/patrykattc/work/jobs/webapp/templates/base.html` should match
2. Verify job_detail.html has apply section: `grep "apply-section\|apply-mode\|Apply Now" /Users/patrykattc/work/jobs/webapp/templates/job_detail.html` should match
3. `python -c "from webapp.app import app; print('App loads OK')"` succeeds
  </verify>
  <done>
base.html loads htmx-ext-sse 2.2.4. job_detail.html has Apply section with mode dropdown, Apply Now button (disabled if already applied), spinner, and SSE status container. Button triggers POST to /jobs/{key}/apply which returns SSE connection HTML.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create apply_status.html partial for SSE-swapped progress updates</name>
  <files>webapp/templates/partials/apply_status.html</files>
  <action>
Create `webapp/templates/partials/apply_status.html` -- this template is rendered server-side for each SSE event and swapped into the `#apply-live-status` div.

The template receives `event` (dict with type, message, screenshot_path, fields_filled) and `dedup_key`:

```html
{# Apply status partial -- rendered per SSE event and swapped into #apply-live-status #}

{% if event.type == "progress" %}
<div class="flex items-center gap-2 py-2">
    <div class="animate-spin h-4 w-4 border-2 border-purple-500 border-t-transparent rounded-full"></div>
    <span class="text-sm text-gray-700">{{ event.message }}</span>
</div>

{% elif event.type == "awaiting_confirm" %}
<div class="bg-yellow-50 border border-yellow-300 rounded p-4">
    <p class="text-sm font-medium text-yellow-800 mb-2">{{ event.message }}</p>
    {% if event.fields_filled %}
    <div class="text-xs text-gray-600 mb-3">
        <p class="font-medium mb-1">Fields auto-filled:</p>
        <ul class="list-disc list-inside">
            {% for field, value in event.fields_filled.items() %}
            <li>{{ field }}: {{ value }}</li>
            {% endfor %}
        </ul>
    </div>
    {% endif %}
    {% if event.screenshot_path %}
    <p class="text-xs text-gray-500 mb-2">Screenshot saved: {{ event.screenshot_path }}</p>
    {% endif %}
    <div class="flex gap-2">
        <button hx-post="/jobs/{{ dedup_key | urlencode }}/apply/confirm"
                hx-target="#apply-status"
                hx-swap="innerHTML"
                class="bg-green-600 text-white px-4 py-1.5 rounded text-sm hover:bg-green-700">
            Confirm & Submit
        </button>
        <button hx-post="/jobs/{{ dedup_key | urlencode }}/apply/cancel"
                hx-target="#apply-status"
                hx-swap="innerHTML"
                class="bg-gray-300 text-gray-700 px-4 py-1.5 rounded text-sm hover:bg-gray-400">
            Cancel
        </button>
    </div>
</div>

{% elif event.type == "captcha" %}
<div class="bg-orange-50 border border-orange-300 rounded p-4">
    <p class="text-sm font-medium text-orange-800 mb-2">CAPTCHA Detected</p>
    <p class="text-sm text-orange-700">{{ event.message }}</p>
    {% if event.screenshot_path %}
    <p class="text-xs text-gray-500 mt-1">Screenshot: {{ event.screenshot_path }}</p>
    {% endif %}
    <p class="text-sm text-orange-700 mt-2">Please solve the CAPTCHA in the browser window, then click Continue.</p>
    <button hx-post="/jobs/{{ dedup_key | urlencode }}/apply/confirm"
            hx-target="#apply-status"
            hx-swap="innerHTML"
            class="mt-2 bg-orange-600 text-white px-4 py-1.5 rounded text-sm hover:bg-orange-700">
        I solved it -- Continue
    </button>
</div>

{% elif event.type == "error" %}
<div class="bg-red-50 border border-red-400 text-red-800 px-4 py-3 rounded">
    <p class="text-sm font-medium">Error</p>
    <p class="text-sm">{{ event.message }}</p>
</div>

{% elif event.type == "done" %}
<div class="{% if event.message and 'success' in event.message.lower() %}bg-green-50 border-green-400 text-green-800{% else %}bg-gray-50 border-gray-300 text-gray-700{% endif %} border px-4 py-3 rounded">
    <p class="text-sm font-medium">{{ event.message or "Apply flow complete" }}</p>
</div>

{% else %}
<div class="py-2">
    <span class="text-sm text-gray-500">{{ event.message }}</span>
</div>
{% endif %}
```

Note: The event dict fields are: type (str), message (str), screenshot_path (str|None), fields_filled (dict|None), job_dedup_key (str).
  </action>
  <verify>
`python -c "from jinja2 import Environment, FileSystemLoader; env = Environment(loader=FileSystemLoader('webapp/templates')); t = env.get_template('partials/apply_status.html'); html = t.render(event={'type': 'progress', 'message': 'Testing...'}, dedup_key='test::key'); print('Rendered OK' if 'Testing...' in html else 'FAILED')"` prints "Rendered OK"
  </verify>
  <done>
apply_status.html partial handles all event types (progress with spinner, awaiting_confirm with Confirm/Cancel buttons, captcha with solve instructions, error in red, done in green/gray). SSE events are rendered server-side and swapped into the DOM.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from sse_starlette import EventSourceResponse; print('OK')"` -- sse-starlette installed
2. `grep 'htmx-ext-sse' webapp/templates/base.html` -- SSE extension loaded
3. `grep 'apply-mode' webapp/templates/job_detail.html` -- Apply UI present
4. `python -c "from jinja2 import Environment, FileSystemLoader; env = Environment(loader=FileSystemLoader('webapp/templates')); t = env.get_template('partials/apply_status.html'); print('OK')"` -- partial loads
5. `python -c "from webapp.app import app; print('App OK')"` -- no import errors
</verification>

<success_criteria>
- sse-starlette is installed and importable
- POST /jobs/{key}/apply starts the apply engine and returns SSE connection HTML
- GET /jobs/{key}/apply/stream returns EventSourceResponse with real-time updates
- POST /jobs/{key}/apply/confirm and /cancel handle human-in-the-loop
- job_detail.html has apply mode dropdown and Apply Now button
- apply_status.html renders all event types with appropriate styling
- Duplicate detection shows warning before starting
- base.html loads htmx-ext-sse 2.2.4
</success_criteria>

<output>
After completion, create `.planning/phases/08-one-click-apply/08-03-SUMMARY.md`
</output>
