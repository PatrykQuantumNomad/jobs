---
phase: 08-one-click-apply
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - apply_engine/engine.py
  - form_filler.py
  - platforms/mixins.py
autonomous: true

must_haves:
  truths:
    - "ApplyEngine.apply() runs sync Playwright in a background thread via asyncio.to_thread()"
    - "Only one apply can run at a time (asyncio.Semaphore(1) enforced)"
    - "Apply engine emits structured ApplyEvent objects to an asyncio.Queue for SSE consumption"
    - "Dashboard-triggered applies use event-based confirmation (threading.Event) instead of stdin input()"
    - "FormFiller detects and switches to ATS iframes before scanning form fields"
    - "Apply engine selects tailored resume if one exists for the job, otherwise falls back to default"
  artifacts:
    - path: "apply_engine/engine.py"
      provides: "ApplyEngine class with async apply() and sync _apply_sync()"
      contains: "class ApplyEngine"
      min_lines: 100
    - path: "form_filler.py"
      provides: "Enhanced FormFiller with iframe detection and cover letter upload"
      contains: "def _detect_ats_iframe"
    - path: "platforms/mixins.py"
      provides: "Event-based wait_for_human alternative for dashboard mode"
      contains: "def wait_for_confirmation"
  key_links:
    - from: "apply_engine/engine.py"
      to: "apply_engine/config.py"
      via: "imports ApplyConfig, ApplyMode"
      pattern: "from apply_engine.config import"
    - from: "apply_engine/engine.py"
      to: "apply_engine/events.py"
      via: "imports ApplyEvent, ApplyEventType"
      pattern: "from apply_engine.events import"
    - from: "apply_engine/engine.py"
      to: "platforms/stealth.py"
      via: "get_browser_context and close_browser"
      pattern: "from platforms import get_browser_context"
    - from: "apply_engine/engine.py"
      to: "form_filler.py"
      via: "FormFiller for external ATS forms"
      pattern: "from form_filler import FormFiller"
    - from: "apply_engine/engine.py"
      to: "apply_engine/dedup.py"
      via: "pre-apply duplicate check"
      pattern: "from apply_engine.dedup import is_already_applied"
---

<objective>
Build the apply engine core that orchestrates the full apply flow: browser launch, login, navigation, form filling, human confirmation, and submission -- all running in a background thread with structured event emission via asyncio.Queue. Also enhance FormFiller with iframe detection for external ATS pages and add event-based confirmation to BrowserPlatformMixin.

Purpose: This is the core runtime that connects the existing platform adapters to the dashboard-triggered apply flow. It bridges sync Playwright with async FastAPI and replaces stdin-based human interaction with event-based confirmation.
Output: `apply_engine/engine.py` with ApplyEngine class, enhanced `form_filler.py`, updated `platforms/mixins.py`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-one-click-apply/08-RESEARCH.md
@.planning/phases/08-one-click-apply/08-01-SUMMARY.md
@apply_engine/config.py
@apply_engine/events.py
@apply_engine/dedup.py
@platforms/protocols.py
@platforms/mixins.py
@platforms/stealth.py
@platforms/registry.py
@platforms/__init__.py
@form_filler.py
@orchestrator.py
@config.py
@models.py
@webapp/db.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create the apply engine with thread bridge and event emission</name>
  <files>apply_engine/engine.py</files>
  <action>
Create `apply_engine/engine.py` with the `ApplyEngine` class:

**Class structure:**
```python
class ApplyEngine:
    """Orchestrates apply flows in a background thread, emitting events to an async queue."""

    def __init__(self, settings=None):
        # Lazy-load settings from config.get_settings() if not provided
        # Create asyncio.Semaphore(1) for apply serialization
        # Store active sessions: dict[str, asyncio.Queue] mapping dedup_key -> event queue
        # Store confirmation events: dict[str, threading.Event] for dashboard confirmation
```

**Key methods:**

1. `async def apply(self, job: dict, mode: str, queue: asyncio.Queue) -> None`:
   - Acquire semaphore (only one apply at a time)
   - Store queue in self._sessions[job["dedup_key"]]
   - Store threading.Event in self._confirmations[job["dedup_key"]]
   - Check duplicate via `is_already_applied(job["dedup_key"])` -- if already applied, emit error event and return
   - Call `await asyncio.to_thread(self._apply_sync, job, mode, self._make_emitter(queue))`
   - In finally block: remove from _sessions and _confirmations, emit DONE event

2. `def _make_emitter(self, queue: asyncio.Queue) -> Callable`:
   - Return a lambda/function that calls `queue.put_nowait(event)` -- thread-safe because `put_nowait` is thread-safe for asyncio.Queue
   - Actually, `put_nowait` is NOT thread-safe. Use `asyncio.get_event_loop().call_soon_threadsafe(queue.put_nowait, event)` instead
   - Wait, the correct pattern from a thread is to use a loop reference. Store the loop in `self._loop = asyncio.get_event_loop()` before spawning the thread, then in the emitter: `self._loop.call_soon_threadsafe(queue.put_nowait, event_dict)` where event_dict is `event.model_dump()`

3. `def _apply_sync(self, job: dict, mode: str, emit: Callable) -> None`:
   - This runs in a background thread (via asyncio.to_thread)
   - Emit PROGRESS: "Starting apply for {job['title']} at {job['company']}..."
   - Determine platform from `job["platform"]`
   - Resolve resume path: check `resume_versions` table for tailored resume via `_get_resume_path(job["dedup_key"])`. If tailored version exists, use it. Otherwise use default ATS resume from settings.
   - Get platform info from registry: `from platforms.registry import get_platform`
   - If API platform (e.g., remoteok): emit PROGRESS "Opening external application page...", then call `self._fill_external_form(job, mode, emit)`, return
   - If browser platform (indeed, dice):
     - Emit PROGRESS: "Launching browser..."
     - `from platforms import get_browser_context, close_browser`
     - `pw, ctx = get_browser_context(platform_name, headless=False)` -- always headed for applies
     - Create platform instance, call `.init(ctx)`
     - Set `platform._confirmation_event = self._confirmations.get(job["dedup_key"])` for event-based confirmation
     - Set `platform._dashboard_mode = True` to signal non-CLI mode
     - Check if logged in, login if needed (emit PROGRESS events)
     - If `mode == "easy_apply_only"` and not `job.get("easy_apply")`: emit ERROR "Job does not support Easy Apply", return
     - Emit PROGRESS: "Navigating to job page..."
     - If screenshot_before_submit: take screenshot, emit PROGRESS with path
     - If confirm_before_submit: emit AWAITING_CONFIRM event with job details, then `self._confirmations[job["dedup_key"]].wait(timeout=300)` -- blocks thread until dashboard confirms or 300s timeout
     - If confirmed: call `platform.apply(job_model, resume_path)`, emit DONE success
     - If timeout: emit ERROR "Confirmation timed out"
     - In finally: `close_browser(pw, ctx)`

4. `def _fill_external_form(self, job: dict, mode: str, emit: Callable) -> None`:
   - For external ATS jobs (apply_url available)
   - If ats_form_fill not enabled in config: emit PROGRESS with apply_url for user to open manually, emit DONE
   - Otherwise: launch browser context (generic, not platform-specific), navigate to apply_url
   - Create FormFiller with candidate profile from settings
   - Call `filler.fill_form(page, resume_path)` -- returns dict of filled fields
   - Emit PROGRESS with fields_filled
   - If confirm_before_submit: emit AWAITING_CONFIRM, wait for confirmation
   - Take screenshot, emit DONE
   - close_browser

5. `def _get_resume_path(self, dedup_key: str) -> Path`:
   - Query `resume_versions` table for the most recent resume for this job
   - If found and file exists on disk, return that path
   - Otherwise return default ATS resume from settings
   - Use `from webapp.db import get_conn` for the query

6. `def confirm(self, dedup_key: str) -> bool`:
   - Called by the dashboard when user clicks "Confirm" button
   - Sets the threading.Event for this dedup_key
   - Returns True if event was found and set, False if no active session

7. `def cancel(self, dedup_key: str) -> bool`:
   - Called by the dashboard when user clicks "Cancel"
   - Does NOT set the event (lets it timeout), but emits a DONE event with success=False
   - Removes from _sessions and _confirmations

8. `def get_session_queue(self, dedup_key: str) -> asyncio.Queue | None`:
   - Returns the active event queue for a job's apply session, or None

**Important implementation details:**
- Use `from __future__ import annotations` for type hints
- Import Playwright lazily inside _apply_sync (not at module level) to avoid import errors when Playwright isn't installed
- Import `Job` from `models` only inside _apply_sync to construct Job model from dict
- Import `from webapp.db import log_activity` to log apply events to activity timeline
- Log activity events: "apply_started" when beginning, "apply_completed" or "apply_failed" at end, with mode and outcome in detail
- Catch all exceptions in _apply_sync, emit ERROR event, log_activity with failure details
  </action>
  <verify>
`python -c "from apply_engine.engine import ApplyEngine; e = ApplyEngine(); print('ApplyEngine created'); print(f'Sessions: {e._sessions}'); print(f'Has confirm: {hasattr(e, \"confirm\")}')"` succeeds with no import errors
  </verify>
  <done>
ApplyEngine class exists with apply(), confirm(), cancel(), get_session_queue() public API. Internal _apply_sync runs Playwright in thread. Events emitted via queue. Semaphore enforces single concurrent apply. Resume path resolution checks tailored versions first. Activity timeline logging on start/complete/fail.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance FormFiller with iframe detection and add event-based confirmation to mixins</name>
  <files>
    form_filler.py
    platforms/mixins.py
  </files>
  <action>
**form_filler.py -- Add iframe detection and cover letter support:**

1. Add a new method `_detect_ats_iframe(self, page: Page) -> Frame | None`:
   - Check for iframes on the page using `page.frames`
   - Look for ATS domains in frame URLs: `boards.greenhouse.io`, `jobs.lever.co`, `jobs.ashbyhq.com`, `app.bamboohr.com`, `workday`
   - If found, return that frame
   - If not found, return None

2. Update `fill_form()` to accept an optional `cover_letter_path: Path | None = None` parameter:
   - Before scanning inputs, call `_detect_ats_iframe(page)`
   - If an ATS iframe is found, scan inputs within that frame instead of the main page
   - Use `frame.query_selector_all("input, textarea, select")` instead of `page.query_selector_all(...)`

3. Add cover letter to `_FIELD_KEYWORDS`:
   ```python
   "cover_letter": ["cover letter", "cover_letter", "coverletter", "additional document"],
   ```

4. Update `_value_for()` to handle "cover_letter" key: return None (file upload handled separately)

5. Add cover letter file upload logic in `fill_form()`: after the main input loop, look for file upload inputs that match cover letter keywords. If found and `cover_letter_path` is provided, call `elem.set_input_files(str(cover_letter_path))`.

6. Add a `linkedin` entry to `_FIELD_KEYWORDS`:
   ```python
   "linkedin": ["linkedin", "linked in"],
   ```
   And update `_value_for` to return empty string for linkedin (profile field not in CandidateProfile).

**platforms/mixins.py -- Add event-based confirmation method:**

1. Add a new method `wait_for_confirmation(self, message: str, timeout: int = 300) -> bool`:
   - If `self._dashboard_mode` is True (set by ApplyEngine):
     - Check for `self._confirmation_event` (a threading.Event)
     - If it exists, call `self._confirmation_event.wait(timeout=timeout)`
     - Return True if event was set (confirmed), False if timeout
   - If not in dashboard mode, fall back to existing `wait_for_human(message)` behavior (return True after stdin input)

2. Do NOT modify the existing `wait_for_human()` method -- it continues to work for CLI mode. The new `wait_for_confirmation()` is an alternative that the apply engine uses.

3. Add default values for the new attributes in `__init__` or as class-level defaults:
   ```python
   _dashboard_mode: bool = False
   _confirmation_event: threading.Event | None = None
   ```
   Use `getattr(self, '_dashboard_mode', False)` pattern (same as existing `_unattended` pattern) to avoid requiring __init__ changes in platform adapters.
  </action>
  <verify>
1. `python -c "from form_filler import FormFiller; f = FormFiller(); print('FormFiller OK'); print(f'Has iframe detect: {hasattr(f, \"_detect_ats_iframe\")}')"` succeeds
2. `python -c "from platforms.mixins import BrowserPlatformMixin; print('Has wait_for_confirmation:', hasattr(BrowserPlatformMixin, 'wait_for_confirmation'))"` prints True
  </verify>
  <done>
FormFiller detects ATS iframes (Greenhouse, Lever, Ashby, BambooHR, Workday) and scans their forms instead of the parent page. Cover letter upload supported. BrowserPlatformMixin has wait_for_confirmation() that works with threading.Event in dashboard mode or falls back to stdin in CLI mode.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from apply_engine.engine import ApplyEngine; e = ApplyEngine(); print('Engine OK')"` succeeds
2. `python -c "from form_filler import FormFiller; f = FormFiller(); print('FormFiller OK')"` succeeds
3. `python -c "from platforms.mixins import BrowserPlatformMixin; m = BrowserPlatformMixin; print(hasattr(m, 'wait_for_confirmation'))"` prints True
4. `python -c "import asyncio; from apply_engine.engine import ApplyEngine; e = ApplyEngine(); print(f'Semaphore: {e._apply_lock}')"` shows semaphore exists
</verification>

<success_criteria>
- ApplyEngine can be instantiated and has apply(), confirm(), cancel() methods
- _apply_sync runs in a thread and emits ApplyEvent objects to a queue
- Semaphore(1) prevents concurrent applies
- Resume path resolution checks tailored versions before falling back to default
- FormFiller detects and switches to ATS iframes
- BrowserPlatformMixin.wait_for_confirmation() supports event-based confirmation
- Activity timeline receives apply_started/apply_completed/apply_failed events
</success_criteria>

<output>
After completion, create `.planning/phases/08-one-click-apply/08-02-SUMMARY.md`
</output>
