---
phase: 08-one-click-apply
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apply_engine/__init__.py
  - apply_engine/config.py
  - apply_engine/events.py
  - apply_engine/dedup.py
  - config.py
  - config.yaml
  - config.example.yaml
autonomous: true

must_haves:
  truths:
    - "ApplyMode enum has three values: full_auto, semi_auto, easy_apply_only"
    - "config.yaml has an apply: section with default_mode, confirm_before_submit, and other settings"
    - "AppSettings loads the apply config section and provides ApplyConfig via settings.apply"
    - "is_already_applied() returns None if not applied, or apply details if already applied"
    - "ApplyEvent model can represent progress, awaiting_confirm, error, and done event types"
  artifacts:
    - path: "apply_engine/__init__.py"
      provides: "Package init with public exports"
    - path: "apply_engine/config.py"
      provides: "ApplyMode enum and ApplyConfig model"
      contains: "class ApplyMode"
    - path: "apply_engine/events.py"
      provides: "ApplyEvent model and event type constants"
      contains: "class ApplyEvent"
    - path: "apply_engine/dedup.py"
      provides: "Pre-apply duplicate detection query"
      contains: "def is_already_applied"
    - path: "config.py"
      provides: "ApplyConfig integrated into AppSettings"
      contains: "apply: ApplyConfig"
    - path: "config.yaml"
      provides: "Apply configuration section"
      contains: "apply:"
    - path: "config.example.yaml"
      provides: "Documented apply configuration example"
      contains: "apply:"
  key_links:
    - from: "config.py"
      to: "apply_engine/config.py"
      via: "import ApplyConfig"
      pattern: "from apply_engine.config import ApplyConfig"
    - from: "apply_engine/dedup.py"
      to: "webapp/db.py"
      via: "get_conn() for SQL query"
      pattern: "from webapp.db import get_conn"
---

<objective>
Create the foundation data models and configuration for the one-click apply feature: ApplyMode enum, ApplyConfig pydantic model, ApplyEvent model for SSE streaming, duplicate detection query, and the apply: section in config.yaml/AppSettings.

Purpose: All subsequent plans (engine, SSE, dashboard) depend on these models and config. This establishes the shared vocabulary and configuration surface.
Output: `apply_engine/` package with config, events, and dedup modules; updated config.py and config.yaml.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-one-click-apply/08-RESEARCH.md
@config.py
@config.yaml
@config.example.yaml
@models.py
@webapp/db.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create apply_engine package with config, events, and dedup modules</name>
  <files>
    apply_engine/__init__.py
    apply_engine/config.py
    apply_engine/events.py
    apply_engine/dedup.py
  </files>
  <action>
Create the `apply_engine/` directory and four files:

**apply_engine/config.py:**
- `ApplyMode(str, Enum)` with three values: `FULL_AUTO = "full_auto"`, `SEMI_AUTO = "semi_auto"`, `EASY_APPLY_ONLY = "easy_apply_only"`
- `ApplyConfig(BaseModel)` with fields:
  - `default_mode: ApplyMode = ApplyMode.SEMI_AUTO`
  - `confirm_before_submit: bool = True` -- always show confirmation before final submit
  - `max_concurrent_applies: int = 1` -- serialize applies (enforced by engine semaphore)
  - `screenshot_before_submit: bool = True` -- screenshot for audit trail
  - `headed_mode: bool = True` -- always visible browser for apply actions
  - `ats_form_fill_enabled: bool = True` -- attempt to fill external ATS forms
  - `ats_form_fill_timeout: int = 120` -- max seconds per form fill attempt

**apply_engine/events.py:**
- `ApplyEventType(str, Enum)` with values: `PROGRESS = "progress"`, `AWAITING_CONFIRM = "awaiting_confirm"`, `CONFIRMED = "confirmed"`, `CAPTCHA = "captcha"`, `ERROR = "error"`, `DONE = "done"`, `PING = "ping"`
- `ApplyEvent(BaseModel)` with fields:
  - `type: ApplyEventType`
  - `message: str = ""` -- human-readable status message
  - `html: str = ""` -- pre-rendered HTML for SSE swap
  - `screenshot_path: str | None = None` -- path to screenshot if CAPTCHA
  - `fields_filled: dict[str, str] | None = None` -- what was auto-filled (for review)
  - `job_dedup_key: str = ""` -- which job this event is for
- Helper function `make_progress_event(message: str, job_dedup_key: str = "") -> ApplyEvent` that constructs a PROGRESS event
- Helper function `make_done_event(message: str, success: bool, job_dedup_key: str = "") -> ApplyEvent` that constructs a DONE event

**apply_engine/dedup.py:**
- `is_already_applied(dedup_key: str) -> dict | None` -- query the jobs table to check if a job has already been applied to. Returns None if not applied, or a dict with `status` and `applied_date` if already applied. Check `applied_date IS NOT NULL OR status IN ('applied', 'phone_screen', 'technical', 'final_interview', 'offer')`. Import `get_conn` from `webapp.db`.

**apply_engine/__init__.py:**
- Export `ApplyMode`, `ApplyConfig`, `ApplyEvent`, `ApplyEventType`, `is_already_applied`
  </action>
  <verify>
`python -c "from apply_engine import ApplyMode, ApplyConfig, ApplyEvent, ApplyEventType, is_already_applied; print('All imports OK'); c = ApplyConfig(); print(f'Default mode: {c.default_mode}'); from apply_engine.events import make_progress_event; e = make_progress_event('test'); print(f'Event type: {e.type}')"` prints "All imports OK", "Default mode: semi_auto", "Event type: progress"
  </verify>
  <done>
apply_engine package exists with all four modules. ApplyMode has 3 values, ApplyConfig has 7 fields with sensible defaults, ApplyEvent has 6 fields, is_already_applied queries the database correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate ApplyConfig into AppSettings and config.yaml</name>
  <files>
    config.py
    config.yaml
    config.example.yaml
  </files>
  <action>
**config.py:**
- Add `from apply_engine.config import ApplyConfig` import at the top (after the existing imports)
- Add `apply: ApplyConfig = Field(default_factory=ApplyConfig)` to the `AppSettings` class, in the "YAML sections" group alongside search, scoring, platforms, timing, schedule
- This makes `get_settings().apply` return the ApplyConfig with defaults if no `apply:` section exists in config.yaml

**config.yaml:**
- Add an `apply:` section at the end of the file:
```yaml
apply:
  default_mode: semi_auto        # full_auto | semi_auto | easy_apply_only
  confirm_before_submit: true     # Always show confirmation before final submit
  max_concurrent_applies: 1       # Serialize -- never run concurrent applies
  screenshot_before_submit: true  # Save screenshot for audit trail
  headed_mode: true               # Always visible browser for apply actions
  ats_form_fill_enabled: true     # Attempt to fill external ATS forms
  ats_form_fill_timeout: 120      # Max time per form fill attempt (seconds)
```

**config.example.yaml:**
- Add a documented `apply:` section at the end, with full comments explaining each field:
```yaml
# -- Apply Configuration ---------------------------------------------------
# Controls how job applications are submitted from the dashboard.
apply:
  # Apply automation level:
  #   full_auto     -- Fill form, wait for user approval, then submit
  #   semi_auto     -- Fill form, user reviews and submits manually
  #   easy_apply_only -- Only use Indeed/Dice Easy Apply (skip external ATS)
  default_mode: semi_auto

  # Always show a confirmation dialog before final form submission,
  # even in full_auto mode. Safety net against accidental applications.
  confirm_before_submit: true

  # Maximum concurrent apply operations. Keep at 1 to avoid browser
  # context conflicts. The engine serializes with a semaphore.
  max_concurrent_applies: 1

  # Save a screenshot of the filled form before submitting.
  # Screenshots go to debug_screenshots/ for audit trail.
  screenshot_before_submit: true

  # Always use visible browser (not headless) for apply actions.
  # Required for CAPTCHA solving and human oversight.
  headed_mode: true

  # Attempt to auto-fill forms on external ATS pages (Greenhouse, Lever, etc.)
  ats_form_fill_enabled: true

  # Maximum time in seconds to spend filling an external ATS form.
  ats_form_fill_timeout: 120
```
  </action>
  <verify>
`python -c "from config import get_settings; s = get_settings(); print(f'Apply mode: {s.apply.default_mode}'); print(f'Confirm: {s.apply.confirm_before_submit}'); print(f'Headed: {s.apply.headed_mode}')"` prints "Apply mode: semi_auto", "Confirm: True", "Headed: True"
  </verify>
  <done>
AppSettings.apply returns an ApplyConfig populated from config.yaml. config.example.yaml has fully documented apply section. get_settings().apply.default_mode returns "semi_auto".
  </done>
</task>

</tasks>

<verification>
1. `python -c "from apply_engine import ApplyMode, ApplyConfig, ApplyEvent, ApplyEventType, is_already_applied; print('All imports OK')"` succeeds
2. `python -c "from config import get_settings; s = get_settings(); print(s.apply.default_mode)"` prints "semi_auto"
3. `python -c "from apply_engine.dedup import is_already_applied; result = is_already_applied('nonexistent_key'); print(f'Result: {result}')"` prints "Result: None"
4. `python -c "from apply_engine.events import ApplyEvent, ApplyEventType; e = ApplyEvent(type=ApplyEventType.DONE, message='Complete'); print(e.model_dump())"` succeeds with correct fields
</verification>

<success_criteria>
- apply_engine/ package exists with config.py, events.py, dedup.py, __init__.py
- ApplyMode has FULL_AUTO, SEMI_AUTO, EASY_APPLY_ONLY values
- ApplyConfig is loadable from config.yaml via AppSettings
- ApplyEvent can represent all event types needed for SSE streaming
- is_already_applied() correctly queries the jobs table
- config.yaml and config.example.yaml have documented apply: sections
</success_criteria>

<output>
After completion, create `.planning/phases/08-one-click-apply/08-01-SUMMARY.md`
</output>
