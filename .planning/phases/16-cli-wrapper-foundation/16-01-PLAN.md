---
phase: 16-cli-wrapper-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - claude_cli/__init__.py
  - claude_cli/client.py
  - claude_cli/exceptions.py
  - claude_cli/parser.py
  - tests/claude_cli/__init__.py
  - tests/claude_cli/conftest.py
  - tests/claude_cli/test_exceptions.py
  - tests/claude_cli/test_parser.py
  - tests/claude_cli/test_client.py
autonomous: true

must_haves:
  truths:
    - "Calling claude_cli.run() with a system prompt, user message, and Pydantic model returns a validated instance of that model"
    - "When Claude CLI is not installed, the wrapper raises CLINotFoundError"
    - "When Claude CLI times out, the wrapper raises CLITimeoutError and kills the process"
    - "When Claude CLI returns malformed JSON, the wrapper raises CLIMalformedOutputError"
    - "When Claude CLI returns an auth error, the wrapper raises CLIAuthError"
    - "When CLI returns structured data in the result field instead of structured_output (regression), the parser still extracts and validates the model"
    - "Cold-start failures are retried once automatically before raising"
  artifacts:
    - path: "claude_cli/__init__.py"
      provides: "Public API exports: run function and all exception classes"
      contains: "from claude_cli.client import run"
    - path: "claude_cli/exceptions.py"
      provides: "Typed exception hierarchy for all CLI error paths"
      contains: "class CLIError"
    - path: "claude_cli/parser.py"
      provides: "Resilient JSON parser handling structured_output and result fallback"
      contains: "def parse_cli_response"
    - path: "claude_cli/client.py"
      provides: "Async subprocess wrapper with retry logic"
      contains: "async def run"
    - path: "tests/claude_cli/test_parser.py"
      provides: "Tests for all parser paths: structured_output, result JSON, result markdown, errors"
      min_lines: 80
    - path: "tests/claude_cli/test_client.py"
      provides: "Tests for subprocess invocation, timeout, auth detection, cold-start retry"
      min_lines: 100
  key_links:
    - from: "claude_cli/client.py"
      to: "claude_cli/parser.py"
      via: "parse_cli_response call after subprocess completes"
      pattern: "parse_cli_response\\(stdout"
    - from: "claude_cli/client.py"
      to: "claude_cli/exceptions.py"
      via: "raises typed exceptions for each error path"
      pattern: "raise CLI(NotFound|Timeout|Auth|Process|Malformed)"
    - from: "claude_cli/parser.py"
      to: "claude_cli/exceptions.py"
      via: "raises CLIMalformedOutputError and CLIResponseError"
      pattern: "raise CLI(Malformed|Response)Error"
    - from: "claude_cli/__init__.py"
      to: "claude_cli/client.py"
      via: "re-exports run function"
      pattern: "from claude_cli\\.client import run"
---

<objective>
Build the claude_cli/ package -- a rock-solid async subprocess wrapper for invoking Claude CLI with typed Pydantic structured output.

Purpose: This is the foundation for all AI features in v1.2. Phases 17, 18, and 19 all depend on this package to call Claude CLI instead of the Anthropic SDK. Getting error handling and the resilient parser right here prevents cascading bugs in downstream phases.

Output: `claude_cli/` package with client, parser, exceptions, and comprehensive test suite.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-cli-wrapper-foundation/16-RESEARCH.md
@resume_ai/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create claude_cli package with exceptions, parser, and client</name>
  <files>
    claude_cli/__init__.py
    claude_cli/exceptions.py
    claude_cli/parser.py
    claude_cli/client.py
  </files>
  <action>
Create a new `claude_cli/` package with four files.

**claude_cli/exceptions.py** -- Typed exception hierarchy:
- `CLIError(Exception)` -- base for all Claude CLI errors
- `CLINotFoundError(CLIError)` -- `shutil.which("claude")` returns None
- `CLITimeoutError(CLIError)` -- subprocess exceeded timeout_seconds
- `CLIAuthError(CLIError)` -- detected auth failure in stderr or envelope
- `CLIProcessError(CLIError)` -- non-zero exit code. Attributes: `returncode: int`, `stderr: str`
- `CLIMalformedOutputError(CLIError)` -- JSON parse or Pydantic validation failure. Attribute: `raw_output: str`
- `CLIResponseError(CLIError)` -- envelope has `is_error=true`. Attribute: `envelope: dict`

Each exception stores enough context for callers (webapp endpoints) to display user-friendly error messages. Follow the exact signatures from the research file Pattern 3.

**claude_cli/parser.py** -- Resilient JSON parser:
- `parse_cli_response(raw_stdout: str, model: type[T]) -> T` where `T` is bound to `BaseModel`
- Path 1: Parse JSON envelope, check `is_error` field -> raise `CLIResponseError` if true
- Path 2: Check `structured_output` field -> `model.model_validate(structured)` -> return
- Path 3: Check `result` field -> try `json.loads(result_text)` -> `model.model_validate()` -> return
- Path 4: Extract JSON from markdown code block in `result` via `re.search(r"```(?:json)?\s*\n?(.*?)\n?\s*```", result_text, re.DOTALL)` -> parse -> validate -> return
- Path 5: Check `subtype == "error_max_structured_output_retries"` -> raise `CLIMalformedOutputError`
- Path 6: If none matched -> raise `CLIMalformedOutputError` with "neither structured_output nor parseable result"
- Truncate raw_output to 500 chars in error messages to avoid flooding logs
- Use `TypeVar` bound to `BaseModel` for proper generic typing

Follow the exact implementation from Research Pattern 2.

**claude_cli/client.py** -- Async subprocess wrapper:
- `async def run(*, system_prompt: str, user_message: str, output_model: type[T], model: str = "sonnet", max_turns: int = 3, timeout_seconds: float = 120.0) -> T`
- Step 1: `shutil.which("claude")` -> `CLINotFoundError` if None
- Step 2: Generate JSON schema via `output_model.model_json_schema()`, serialize with `json.dumps()`
- Step 3: Build command list: `[claude_path, "-p", user_message, "--output-format", "json", "--json-schema", schema_json, "--system-prompt", system_prompt, "--model", model, "--max-turns", str(max_turns), "--no-session-persistence", "--tools", ""]`
- Step 4: `asyncio.create_subprocess_exec(*cmd, stdout=PIPE, stderr=PIPE)` per decision in STATE.md (not subprocess.run in to_thread)
- Step 5: `asyncio.wait_for(proc.communicate(), timeout=timeout_seconds)` -- on `TimeoutError`: `proc.kill()`, `await proc.wait()`, raise `CLITimeoutError`
- Step 6: On non-zero returncode: detect auth errors via `_detect_auth_error(returncode, stderr, envelope=None)` -> raise `CLIAuthError` if detected, else raise `CLIProcessError`
- Step 7: Call `parse_cli_response(stdout.decode(), output_model)`
- **Cold-start retry**: Wrap the entire execute+parse in a retry loop (max 1 retry). If the first attempt raises `CLIProcessError` or `CLIMalformedOutputError`, log a warning "CLI cold-start retry" and try once more. If the retry also fails, re-raise.
- Auth error detection helper `_detect_auth_error(returncode: int, stderr: str, envelope: dict | None) -> bool`: check stderr.lower() for keywords ["not authenticated", "login", "auth", "setup-token", "subscription"]. Also check envelope.get("result") if envelope and envelope.get("is_error").
- Use `logging.getLogger(__name__)` for debug logging of invocations and retries.

**claude_cli/__init__.py** -- Public API:
```python
from claude_cli.client import run
from claude_cli.exceptions import (
    CLIAuthError,
    CLIError,
    CLIMalformedOutputError,
    CLINotFoundError,
    CLIProcessError,
    CLIResponseError,
    CLITimeoutError,
)
```

Add `__all__` listing all exports.

All files must have module docstrings per project conventions. Use absolute imports. Type hints on all signatures. Use `str | None` style unions (Python 3.14).
  </action>
  <verify>
    Run: `uv run ruff check claude_cli/ && uv run ruff format --check claude_cli/`
    Both commands exit 0 with no issues.
    Run: `python -c "from claude_cli import run, CLIError, CLINotFoundError, CLITimeoutError, CLIAuthError, CLIProcessError, CLIMalformedOutputError, CLIResponseError; print('imports ok')"` -- prints "imports ok".
  </verify>
  <done>
    claude_cli/ package exists with four files. All exception classes are importable. `run()` is importable. `parse_cli_response()` is importable from `claude_cli.parser`. Ruff passes with no errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Comprehensive tests for parser, exceptions, and client</name>
  <files>
    tests/claude_cli/__init__.py
    tests/claude_cli/conftest.py
    tests/claude_cli/test_exceptions.py
    tests/claude_cli/test_parser.py
    tests/claude_cli/test_client.py
  </files>
  <action>
Create test suite for the claude_cli package using subprocess mocks (never real CLI calls).

**tests/claude_cli/__init__.py** -- Empty.

**tests/claude_cli/conftest.py** -- Shared fixtures:
- `SampleModel(BaseModel)` with fields `answer: int` and `reasoning: str` -- used across all tests as the output_model
- `sample_envelope(structured_output: dict | None = None, result: str = "", is_error: bool = False, subtype: str = "success") -> str` -- helper that returns a JSON string matching the CLI envelope format: `{"type": "result", "subtype": subtype, "is_error": is_error, "result": result, "structured_output": structured_output, "duration_ms": 1000, "num_turns": 2}`
- `mock_subprocess` fixture that patches `asyncio.create_subprocess_exec` and returns a mock process object with configurable `stdout`, `stderr`, `returncode`, and `communicate()` as an async coroutine. Default: returncode=0, stderr=b"".

**tests/claude_cli/test_exceptions.py** -- Unit tests (mark @pytest.mark.unit):
- Test each exception can be instantiated with expected args
- Test `CLIProcessError` stores `returncode` and `stderr` attributes
- Test `CLIMalformedOutputError` stores `raw_output` attribute
- Test `CLIResponseError` stores `envelope` attribute
- Test inheritance: all exceptions are subclasses of `CLIError` and `Exception`

**tests/claude_cli/test_parser.py** -- Unit tests (mark @pytest.mark.unit):
- `test_parse_structured_output_success`: envelope with `structured_output: {"answer": 42, "reasoning": "because"}` returns validated SampleModel
- `test_parse_result_json_fallback`: envelope with `structured_output: null`, `result: '{"answer": 42, "reasoning": "because"}'` returns validated SampleModel (regression path)
- `test_parse_result_markdown_fallback`: envelope with `result: '```json\n{"answer": 42, "reasoning": "because"}\n```'` returns validated SampleModel
- `test_parse_result_markdown_no_lang_tag`: envelope with `result: '```\n{"answer": 42}\n```'` -- handles missing "json" tag
- `test_parse_is_error_raises_response_error`: envelope with `is_error: true` raises `CLIResponseError` with envelope stored
- `test_parse_invalid_json_raises_malformed`: raw_stdout is not JSON at all -> raises `CLIMalformedOutputError`
- `test_parse_structured_output_validation_error`: structured_output contains `{"answer": "not_a_number"}` -> raises `CLIMalformedOutputError` (Pydantic validation fail)
- `test_parse_max_retries_subtype`: envelope with `subtype: "error_max_structured_output_retries"` and no structured_output -> raises `CLIMalformedOutputError` with "exhausted retries"
- `test_parse_empty_result_no_structured_output`: envelope with `structured_output: null`, `result: ""` -> raises `CLIMalformedOutputError`
- `test_parse_raw_output_truncated`: Error message raw_output is truncated to 500 chars max

**tests/claude_cli/test_client.py** -- Unit tests (mark @pytest.mark.unit), all async:
- `test_run_success`: mock subprocess returns valid envelope with structured_output -> returns validated SampleModel. Verify command list includes "-p", "--output-format", "json", "--json-schema", "--system-prompt", "--model", "--max-turns", "--no-session-persistence", "--tools", "".
- `test_run_cli_not_found`: patch `shutil.which` to return None -> raises `CLINotFoundError`
- `test_run_timeout`: mock `communicate()` to hang (use `asyncio.sleep(999)` in mock) -> raises `CLITimeoutError`. Use a short timeout_seconds=0.1.
- `test_run_nonzero_exit`: mock returncode=1, stderr=b"some error" -> raises `CLIProcessError` with returncode=1
- `test_run_auth_error_detected`: mock returncode=1, stderr=b"not authenticated, run setup-token" -> raises `CLIAuthError` (not CLIProcessError)
- `test_run_cold_start_retry`: first call raises `CLIProcessError`, second call succeeds -> returns model. Verify subprocess was called twice.
- `test_run_cold_start_retry_exhausted`: both calls fail -> raises the second exception
- `test_run_custom_model_and_timeout`: pass model="opus", timeout_seconds=60 -> verify they appear in command and wait_for call
- `test_run_auth_error_in_envelope`: mock returncode=0 but envelope has `is_error: true`, result contains "auth" -> raises `CLIAuthError`

All async tests need `@pytest.mark.asyncio` decorator. Use `unittest.mock.AsyncMock` for `communicate()`. Patch `shutil.which` to return "/usr/local/bin/claude" by default (except in not-found test).
  </action>
  <verify>
    Run: `uv run pytest tests/claude_cli/ -v --no-header`
    All tests pass. At least 20 tests total across the three test files.
    Run: `uv run ruff check tests/claude_cli/ && uv run ruff format --check tests/claude_cli/`
    Both exit 0.
  </verify>
  <done>
    All claude_cli tests pass. Coverage: every exception class tested for construction and inheritance, every parser path tested (structured_output, result JSON, result markdown, is_error, validation error, max retries, empty), every client path tested (success, not found, timeout, non-zero exit, auth error, cold-start retry, custom params). No real subprocess calls -- all mocked.
  </done>
</task>

</tasks>

<verification>
1. `uv run ruff check claude_cli/ tests/claude_cli/` -- no lint errors
2. `uv run pytest tests/claude_cli/ -v` -- all tests pass
3. `python -c "from claude_cli import run, CLIError"` -- imports succeed
4. `uv run pytest tests/ -v --no-header` -- full test suite still passes (no regressions)
</verification>

<success_criteria>
- claude_cli/ package with 4 files: __init__.py, client.py, exceptions.py, parser.py
- 7 exception classes in hierarchy under CLIError
- Resilient parser handles structured_output (normal) and result field (regression)
- Async client with timeout, auth detection, and cold-start retry
- 20+ tests covering all error paths with subprocess mocks
- Full existing test suite passes (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/16-cli-wrapper-foundation/16-01-SUMMARY.md`
</output>
