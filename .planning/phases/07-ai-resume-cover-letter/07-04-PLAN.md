---
phase: 07-ai-resume-cover-letter
plan: 04
type: execute
wave: 3
depends_on: ["07-02", "07-03"]
files_modified:
  - webapp/app.py
  - webapp/templates/job_detail.html
  - webapp/templates/partials/resume_diff.html
  - webapp/templates/partials/resume_versions.html
autonomous: false

must_haves:
  truths:
    - "User clicks 'Tailor Resume' on a job and receives a diff view + PDF download link"
    - "User clicks 'Generate Cover Letter' on a job and receives a PDF download link"
    - "Generated PDFs are downloadable from the dashboard"
    - "Resume versions for a job are visible on the job detail page"
    - "All generated files are stored in resumes/tailored/ with company+date naming"
    - "Resume generation activity is logged in the activity timeline"
    - "Post-generation validation runs on tailored resume and warns user if fabricated entities detected"
  artifacts:
    - path: "webapp/app.py"
      provides: "POST /jobs/{key}/tailor-resume, POST /jobs/{key}/cover-letter, GET /resumes/tailored/{filename} endpoints"
      contains: "tailor-resume"
    - path: "webapp/templates/job_detail.html"
      provides: "Tailor Resume and Generate Cover Letter buttons, resume versions section"
      contains: "tailor-resume"
    - path: "webapp/templates/partials/resume_diff.html"
      provides: "htmx partial showing diff view + download link + tailoring notes + fabrication warning banner"
      contains: "diff_html"
    - path: "webapp/templates/partials/resume_versions.html"
      provides: "htmx partial listing resume versions for a job"
      contains: "resume_type"
  key_links:
    - from: "webapp/app.py"
      to: "resume_ai/tailor.py"
      via: "asyncio.to_thread(tailor_resume, ...)"
      pattern: "asyncio\\.to_thread.*tailor_resume"
    - from: "webapp/app.py"
      to: "resume_ai/cover_letter.py"
      via: "asyncio.to_thread(generate_cover_letter, ...)"
      pattern: "asyncio\\.to_thread.*generate_cover_letter"
    - from: "webapp/app.py"
      to: "resume_ai/renderer.py"
      via: "render_resume_pdf and render_cover_letter_pdf"
      pattern: "render_resume_pdf|render_cover_letter_pdf"
    - from: "webapp/app.py"
      to: "resume_ai/tracker.py"
      via: "save_resume_version, get_versions_for_job"
      pattern: "save_resume_version|get_versions_for_job"
    - from: "webapp/app.py"
      to: "resume_ai/diff.py"
      via: "generate_resume_diff_html"
      pattern: "generate_resume_diff_html"
    - from: "webapp/app.py"
      to: "resume_ai/extractor.py"
      via: "extract_resume_text for original resume"
      pattern: "extract_resume_text"
    - from: "webapp/app.py"
      to: "resume_ai/validator.py"
      via: "validate_no_fabrication for post-generation check"
      pattern: "validate_no_fabrication"
    - from: "webapp/templates/job_detail.html"
      to: "webapp/app.py"
      via: "hx-post to /jobs/{key}/tailor-resume and /jobs/{key}/cover-letter"
      pattern: "hx-post"
---

<objective>
Wire the resume AI module into the web dashboard: add "Tailor Resume" and "Generate Cover Letter" buttons to the job detail page, create the API endpoints that call the AI functions, run post-generation anti-fabrication validation, render diff views with warning banners if fabrication is detected, serve PDF downloads, and show resume version history.

Purpose: This is the user-facing integration that makes the AI capabilities accessible. Without this plan, the resume_ai module would be a library with no UI. This plan delivers Success Criteria #1 (tailor button + PDF), #2 (diff view + anti-fabrication validation), #3 (cover letter button), #4 (version tracking in UI), and #5 (file storage with naming convention).

Output: Updated `webapp/app.py` with new endpoints, updated `job_detail.html` with AI buttons, two new partials for diff view and version list.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-ai-resume-cover-letter/07-RESEARCH.md
@.planning/phases/07-ai-resume-cover-letter/07-01-SUMMARY.md
@.planning/phases/07-ai-resume-cover-letter/07-02-SUMMARY.md
@.planning/phases/07-ai-resume-cover-letter/07-03-SUMMARY.md
@webapp/app.py
@webapp/templates/job_detail.html
@webapp/db.py
@config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: API endpoints for resume tailoring and cover letter generation</name>
  <files>webapp/app.py</files>
  <action>
Add the following to `webapp/app.py`:

1. New imports at top:
   - `import asyncio`
   - `from datetime import date` (already imported)
   - `from pathlib import Path` (already imported)
   - `from fastapi.responses import FileResponse` (add to existing import)
   - `from config import get_settings, RESUMES_TAILORED_DIR`
   - `from resume_ai.extractor import extract_resume_text`
   - `from resume_ai.tailor import tailor_resume, format_resume_as_text`
   - `from resume_ai.cover_letter import generate_cover_letter, format_cover_letter_as_text`
   - `from resume_ai.renderer import render_resume_pdf, render_cover_letter_pdf`
   - `from resume_ai.diff import generate_resume_diff_html, wrap_diff_html`
   - `from resume_ai.tracker import save_resume_version, get_versions_for_job`
   - `from resume_ai.validator import validate_no_fabrication`

2. POST `/jobs/{dedup_key:path}/tailor-resume` endpoint:
   - Fetch job from db.get_job(dedup_key). Return 404 if not found.
   - Get settings via get_settings(). Get resume path from settings.candidate_resume_path.
   - Extract original resume text: `resume_text = extract_resume_text(settings.candidate_resume_path)`
   - Call LLM via thread to avoid blocking: `tailored = await asyncio.to_thread(tailor_resume, resume_text=resume_text, job_description=job["description"] or "", job_title=job["title"], company_name=job["company"])`
   - Generate tailored text and diff: `tailored_text = format_resume_as_text(tailored)`, `diff_html = generate_resume_diff_html(resume_text, tailored_text)`, `diff_styled = wrap_diff_html(diff_html)`
   - **Run post-generation validation:** `validation = validate_no_fabrication(resume_text, tailored_text)`. Pass `validation_warnings=validation.warnings` and `validation_valid=validation.is_valid` to the template context.
   - Generate PDF: Build filename as `Patryk_Golabek_Resume_{company_slug}_{date.today().isoformat()}.pdf` where company_slug is `job["company"].replace(" ", "_")[:30]`. Output path = `RESUMES_TAILORED_DIR / filename`.
   - Build contact_info string from settings: `f"{settings.candidate_email} | {settings.candidate_phone} | {settings.candidate_location}"`.
   - Call `render_resume_pdf(tailored, f"{settings.candidate_first_name} {settings.candidate_last_name}", contact_info, output_path)`.
   - Track version: `save_resume_version(job_dedup_key=dedup_key, resume_type="resume", file_path=str(output_path), original_resume_path=settings.candidate_resume_path, model_used="claude-sonnet-4-5-20250929")`
   - Log activity: `db.log_activity(dedup_key, "resume_tailored", detail=f"Generated tailored resume: {filename}")`
   - Return htmx partial `partials/resume_diff.html` with context: request, diff_html=diff_styled, download_url=f"/resumes/tailored/{filename}", tailoring_notes=tailored.tailoring_notes, filename=filename, validation_valid=validation.is_valid, validation_warnings=validation.warnings.
   - Wrap the entire LLM + render pipeline in try/except. On error, return an HTML error message: `<div class="text-red-600 p-4">{error message}</div>`.

3. POST `/jobs/{dedup_key:path}/cover-letter` endpoint:
   - Same pattern: fetch job, extract resume text, call generate_cover_letter via asyncio.to_thread.
   - Build filename: `Patryk_Golabek_CoverLetter_{company_slug}_{date.today().isoformat()}.pdf`
   - Render PDF via render_cover_letter_pdf with candidate info from settings.
   - Save version with resume_type="cover_letter".
   - Log activity: `db.log_activity(dedup_key, "cover_letter_generated", detail=f"Generated cover letter: {filename}")`
   - Return htmx partial with download link (reuse a simpler version of the diff partial, or create inline HTML response with download link and success message).

4. GET `/resumes/tailored/{filename:path}` endpoint:
   - Serve the file from RESUMES_TAILORED_DIR using FileResponse.
   - Check file exists first, return 404 if not.
   - Set media_type="application/pdf".

5. GET `/jobs/{dedup_key:path}/resume-versions` endpoint:
   - Call get_versions_for_job(dedup_key).
   - Return htmx partial `partials/resume_versions.html` with versions list.

6. Error handling: If ANTHROPIC_API_KEY is not set, the Anthropic client will raise AuthenticationError. The try/except in the endpoint should catch this and return a user-friendly message: "Anthropic API key not configured. Add ANTHROPIC_API_KEY to your .env file."
  </action>
  <verify>
Run: `python -c "from config import get_settings, RESUMES_TAILORED_DIR; print('Config imports OK')"` -- config constants importable.
Run: `python -c "from webapp.app import app; routes = [r.path for r in app.routes]; assert '/jobs/{dedup_key:path}/tailor-resume' in routes or any('tailor-resume' in str(r.path) for r in app.routes); print('Endpoints registered')"` -- new routes exist.
Run: `ruff check webapp/app.py` -- no lint errors.
  </verify>
  <done>
Five new endpoints added to webapp/app.py: tailor-resume (POST), cover-letter (POST), resume download (GET), resume-versions (GET). All LLM calls wrapped in asyncio.to_thread. Post-generation validation via validate_no_fabrication() runs before returning diff view. Error handling for missing API key. Activity logging for generation events.
  </done>
</task>

<task type="auto">
  <name>Task 2: Dashboard UI integration (buttons, diff view with validation warning, version list)</name>
  <files>
    webapp/templates/job_detail.html
    webapp/templates/partials/resume_diff.html
    webapp/templates/partials/resume_versions.html
  </files>
  <action>
1. Create `webapp/templates/partials/resume_diff.html`:
   - An htmx partial (no extends, no base.html inheritance).
   - Shows:
     - **Anti-fabrication warning banner** (conditionally displayed):
       ```html
       {% if not validation_valid %}
       <div class="bg-amber-50 border border-amber-400 text-amber-800 px-4 py-3 rounded mb-4">
         <p class="font-bold">Warning: Potential fabrication detected</p>
         <p class="text-sm">The validator found entities in the tailored resume that do not appear in the original. Please review carefully before using this resume:</p>
         <ul class="list-disc list-inside text-sm mt-2">
           {% for warning in validation_warnings %}
           <li>{{ warning }}</li>
           {% endfor %}
         </ul>
       </div>
       {% else %}
       <div class="bg-green-50 border border-green-400 text-green-800 px-4 py-3 rounded mb-4">
         <p class="text-sm font-medium">Validation passed: No fabricated content detected</p>
       </div>
       {% endif %}
       ```
     - A success banner: "Resume tailored successfully"
     - Tailoring notes in a collapsible/visible section: `<p class="text-sm text-gray-600 italic mb-4">{{ tailoring_notes }}</p>`
     - Download link: `<a href="{{ download_url }}" class="inline-block bg-indigo-600 text-white px-4 py-2 rounded text-sm hover:bg-indigo-700 mb-4" download>Download PDF ({{ filename }})</a>`
     - The diff HTML table: `{{ diff_html | safe }}`
     - A "Regenerate" button that re-triggers the tailor-resume endpoint (same hx-post)

2. Create `webapp/templates/partials/resume_versions.html`:
   - An htmx partial showing a list of previously generated resume versions.
   - For each version: type badge (Resume/Cover Letter), date (created_at), download link (file_path converted to download URL), model used.
   - If no versions: "No tailored documents yet."
   - Use Tailwind classes consistent with existing dashboard styling.

3. Update `webapp/templates/job_detail.html`:
   - Add a new section in the sidebar (between "Notes" and "Activity Timeline") titled "AI Resume Tools":
     - "Tailor Resume" button: `<button hx-post="/jobs/{{ job.dedup_key | urlencode }}/tailor-resume" hx-target="#resume-ai-result" hx-swap="innerHTML" hx-indicator="#resume-spinner" class="w-full bg-indigo-600 text-white px-4 py-2 rounded text-sm hover:bg-indigo-700 mb-2">Tailor Resume</button>`
     - "Generate Cover Letter" button: `<button hx-post="/jobs/{{ job.dedup_key | urlencode }}/cover-letter" hx-target="#resume-ai-result" hx-swap="innerHTML" hx-indicator="#resume-spinner" class="w-full bg-emerald-600 text-white px-4 py-2 rounded text-sm hover:bg-emerald-700 mb-2">Generate Cover Letter</button>`
     - A loading spinner indicator: `<div id="resume-spinner" class="htmx-indicator text-center py-4"><span class="text-sm text-gray-500">Generating... this may take 10-15 seconds</span></div>`
     - Result container: `<div id="resume-ai-result"></div>`

   - Add a "Resume Versions" section below the AI tools section:
     - Container div with hx-get="/jobs/{{ job.dedup_key | urlencode }}/resume-versions" hx-trigger="load" hx-target="this" to lazy-load versions on page load.
     - This keeps the initial page load fast while fetching version history asynchronously.

   - Add new activity event types to the activity timeline section:
     - `{% elif event.event_type == 'resume_tailored' %}` with purple dot color (bg-purple-400): "Resume tailored" with detail text
     - `{% elif event.event_type == 'cover_letter_generated' %}` with emerald dot color (bg-emerald-400): "Cover letter generated" with detail text

4. Ensure the job detail page loads the htmx library (it should already be in base.html from Phase 5).
  </action>
  <verify>
Start the webapp and visually verify on a job detail page:
1. "AI Resume Tools" section appears in sidebar with two buttons
2. Buttons have loading indicator text
3. Resume versions section lazy-loads on page open
4. Activity timeline recognizes resume_tailored and cover_letter_generated event types

Run: `ruff check webapp/templates/` -- no issues (templates aren't Python, but check no syntax issues in embedded code).
Run: `python -c "from jinja2 import Environment, FileSystemLoader; env = Environment(loader=FileSystemLoader('webapp/templates')); env.get_template('partials/resume_diff.html'); env.get_template('partials/resume_versions.html'); print('Partials OK')"` -- templates loadable.
  </verify>
  <done>
Job detail page has "Tailor Resume" and "Generate Cover Letter" buttons with htmx integration. Diff view partial shows side-by-side comparison with download link AND an anti-fabrication validation banner (amber warning if fabrication detected, green confirmation if clean). Resume versions partial shows generation history. Activity timeline renders resume-related events. Loading spinner provides feedback during LLM generation.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete AI resume tailoring and cover letter pipeline integrated into the dashboard. Clicking "Tailor Resume" on any job extracts the user's PDF resume, sends it with the job description to Claude, receives a tailored version with anti-fabrication guardrails (system prompt + temperature=0 + post-generation entity validation + diff view), generates a diff view with validation status banner, produces a downloadable PDF, and tracks the version in SQLite.</what-built>
  <how-to-verify>
1. Ensure ANTHROPIC_API_KEY is set in your .env file
2. Ensure WeasyPrint system dependency is installed: `brew install weasyprint` (or `brew install pango`)
3. Start the dashboard: `python -m webapp.app`
4. Open http://127.0.0.1:8000 and click on any job with a description
5. In the sidebar, click "Tailor Resume" -- wait 10-15 seconds for the LLM response
6. Verify:
   - A validation banner appears at the top of the result:
     - GREEN "Validation passed" banner if no fabrication detected
     - AMBER warning banner listing specific entities if fabrication detected
   - A diff view appears showing original vs tailored resume side-by-side
   - Tailoring notes explain what was changed
   - A "Download PDF" link is present -- click it and verify the PDF is a professional resume
   - The PDF is saved in resumes/tailored/ with company name and date in filename
   - The activity timeline shows "Resume tailored" event
7. Click "Generate Cover Letter" -- wait for response
8. Verify:
   - A download link appears for the cover letter PDF
   - The PDF references the specific company and role
   - Activity timeline shows "Cover letter generated" event
9. Check the "Resume Versions" section shows both generated documents
10. Verify anti-fabrication: open the diff view and confirm no new skills/companies/metrics were added -- only reordering and emphasis changes. The validation banner should confirm this programmatically.
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. POST /jobs/{key}/tailor-resume returns diff view + PDF download link + validation status
2. POST /jobs/{key}/cover-letter returns download link for cover letter PDF
3. GET /resumes/tailored/{filename} serves the PDF file
4. Job detail page shows "AI Resume Tools" section with both buttons
5. Loading spinner visible during generation
6. Resume versions listed on job detail page
7. Activity timeline records resume_tailored and cover_letter_generated events
8. Generated PDFs exist in resumes/tailored/ with proper naming
9. Diff view shows side-by-side comparison with color-coded changes
10. Anti-fabrication validation banner shows green (pass) or amber (warning with details)
</verification>

<success_criteria>
- User can click "Tailor Resume" on any job and receive a diff view + downloadable PDF
- User can click "Generate Cover Letter" and receive a downloadable PDF
- The diff view shows exactly what changed between original and tailored resume
- Post-generation validation runs automatically and displays results (green pass or amber warning with entity list)
- Resume versions are tracked and visible per job
- Generated files stored in resumes/tailored/ with company+date naming
- Activity timeline records all generation events
- Missing API key produces a clear error message (not a crash)
- LLM calls do not block the event loop (asyncio.to_thread)
</success_criteria>

<output>
After completion, create `.planning/phases/07-ai-resume-cover-letter/07-04-SUMMARY.md`
</output>
