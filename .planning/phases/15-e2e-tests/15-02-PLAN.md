---
phase: 15-e2e-tests
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - tests/e2e/test_kanban.py
  - tests/e2e/test_export.py
  - .github/workflows/ci.yml
autonomous: true

must_haves:
  truths:
    - "Kanban board drag-and-drop moves a job card between columns and the new status persists in the database"
    - "Export buttons trigger file downloads that contain valid CSV/JSON data matching the displayed jobs"
    - "CI E2E command works without socket-blocking errors"
  artifacts:
    - path: "tests/e2e/test_kanban.py"
      provides: "Kanban drag-and-drop E2E tests"
      contains: "class TestKanbanE2E"
    - path: "tests/e2e/test_export.py"
      provides: "CSV/JSON export download E2E tests"
      contains: "class TestExportE2E"
    - path: ".github/workflows/ci.yml"
      provides: "Fixed E2E CI command with socket plugin disabled"
      contains: "-p no:socket"
  key_links:
    - from: "tests/e2e/test_kanban.py"
      to: "webapp/templates/kanban.html"
      via: "SortableJS drag-and-drop on .kanban-list columns"
      pattern: "col-saved|col-applied|kanban-card"
    - from: "tests/e2e/test_export.py"
      to: "webapp/app.py export_csv/export_json"
      via: "page.expect_download() on #export-csv-link / #export-json-link"
      pattern: "expect_download"
    - from: ".github/workflows/ci.yml"
      to: "tests/e2e/"
      via: "pytest -m e2e -p no:socket command"
      pattern: "pytest -m e2e -p no:socket"
---

<objective>
Write kanban drag-and-drop and export download E2E tests, and fix the CI E2E command.

Purpose: Complete the remaining E2E requirements (E2E-04, E2E-05) and ensure CI can actually run the E2E tests without socket-blocking errors. The kanban test validates the most complex client-side interaction (SortableJS drag-and-drop with server persistence), and the export tests validate that file downloads produce valid data.

Output: Two test files (`test_kanban.py`, `test_export.py`) and a CI workflow fix.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-e2e-tests/15-RESEARCH.md
@.planning/phases/15-e2e-tests/15-01-SUMMARY.md

@webapp/app.py
@webapp/templates/kanban.html
@webapp/templates/partials/kanban_card.html
@webapp/templates/dashboard.html
@webapp/db.py
@tests/e2e/conftest.py
@.github/workflows/ci.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write kanban drag-and-drop E2E test (E2E-04)</name>
  <files>tests/e2e/test_kanban.py</files>
  <action>
Create `tests/e2e/test_kanban.py` with class `TestKanbanE2E` decorated with `@pytest.mark.e2e` and `@pytest.mark.enable_socket`.

Add `from __future__ import annotations` and `from playwright.sync_api import expect`.

The kanban page at `/kanban` displays columns for statuses: saved, applied, phone_screen, technical, final_interview, offer, rejected, withdrawn, ghosted. Each column is a `div.kanban-list` with `data-status="{status}"` and `id="col-{status}"`. Cards are `div.kanban-card` with `data-key="{dedup_key}"`.

SortableJS uses `forceFallback: true`, so native `drag_to()` will NOT work. Must use manual mouse events.

**Helper function `_drag_card_to_column(page, card_locator, target_column_locator)`:**
- Get bounding boxes: `source_box = card_locator.bounding_box()`, `target_box = target_column_locator.bounding_box()`
- Move mouse to center of card: `page.mouse.move(source_box["x"] + source_box["width"] / 2, source_box["y"] + source_box["height"] / 2)`
- Press down: `page.mouse.down()`
- Small delay for SortableJS to register: `page.wait_for_timeout(100)`
- Move to target column center with steps: `target_x = target_box["x"] + target_box["width"] / 2; target_y = target_box["y"] + target_box["height"] / 2; page.mouse.move(target_x, target_y, steps=20)`
- Second move for SortableJS to finalize: `page.mouse.move(target_x, target_y)`
- Small delay: `page.wait_for_timeout(100)`
- Release: `page.mouse.up()`

**seeded_kanban_db fixture (in this file or conftest, file-level is fine):**
The seeded_db from conftest creates jobs with status "scored" and one with "saved". For kanban, we need jobs in kanban-visible statuses (saved, applied, etc. -- "scored" is NOT a kanban status). So create a fixture that:
- Depends on `_fresh_db`
- Creates 3 jobs with status "saved" (one per platform, scores 3, 4, 5)
- Creates 2 jobs with status "applied"
- Upserts all via `db_module.upsert_job()` then `db_module.update_job_status(dedup_key, status)` for each
- Returns the list of jobs

**Test 1: `test_kanban_page_loads_with_columns`**
- Navigate to `/kanban` with `seeded_kanban_db`
- Verify all kanban columns exist: for each status in ["saved", "applied", ...], assert `page.locator(f"#col-{status}")` is visible
- Verify "saved" column has 3 cards: `expect(page.locator("#col-saved .kanban-card")).to_have_count(3)`
- Verify "applied" column has 2 cards: `expect(page.locator("#col-applied .kanban-card")).to_have_count(2)`

**Test 2: `test_drag_card_from_saved_to_applied`**
- Navigate to `/kanban` with `seeded_kanban_db`
- Wait for SortableJS to load: `page.wait_for_function("typeof Sortable !== 'undefined'")`
- Locate first card in "saved" column: `card = page.locator("#col-saved .kanban-card").first`
- Store the card's `data-key` attribute: `card_key = card.get_attribute("data-key")`
- Locate the "applied" column: `target = page.locator("#col-applied")`
- Call `_drag_card_to_column(page, card, target)`
- Wait for the htmx POST to `/status` to complete: `page.wait_for_response(lambda r: "/status" in r.url, timeout=5000)`
- Verify card moved: `expect(page.locator("#col-saved .kanban-card")).to_have_count(2)` and `expect(page.locator("#col-applied .kanban-card")).to_have_count(3)`
- Verify persistence: reload the page, re-navigate to `/kanban`, confirm same counts

**IMPORTANT NOTE on drag-and-drop:** If the manual mouse approach proves flaky during execution, fall back to testing the underlying htmx POST directly. Create a hybrid test that:
1. Verifies the kanban page loads with correct columns/cards
2. Simulates what SortableJS does on drag-end: `page.evaluate("htmx.ajax('POST', '/jobs/' + encodeURIComponent(cardKey) + '/status', {values: {status: 'applied'}})")` where `cardKey` is the data-key
3. Reloads and verifies the card moved columns

Document which approach was used in the test docstring. Both are valid for E2E-04 since they test the full stack persistence path.
  </action>
  <verify>
Run `uv run pytest tests/e2e/test_kanban.py -m e2e -p no:socket -v` and verify both tests pass (or the fallback hybrid approach passes if drag-and-drop is flaky).
  </verify>
  <done>Kanban page loads with correct column layout and card counts. Drag-and-drop (or equivalent status update) moves a card between columns and the change persists after reload.</done>
</task>

<task type="auto">
  <name>Task 2: Write export download E2E tests (E2E-05)</name>
  <files>tests/e2e/test_export.py</files>
  <action>
Create `tests/e2e/test_export.py` with class `TestExportE2E` decorated with `@pytest.mark.e2e` and `@pytest.mark.enable_socket`.

Add `from __future__ import annotations`, `import csv`, `import io`, `import json`, and `from playwright.sync_api import expect`.

Uses `seeded_db` fixture from conftest.py (10 jobs total).

**Test 1: `test_csv_export_downloads_valid_file`**
- Navigate to dashboard: `page.goto(f"{live_server}/")`
- Trigger download: `with page.expect_download() as download_info: page.locator("#export-csv-link").click()`
- Get download object: `download = download_info.value`
- Assert filename: `assert download.suggested_filename.endswith(".csv")` and `assert "jobs_export_" in download.suggested_filename`
- Read and validate content:
  ```python
  content = download.path().read_text()
  reader = csv.DictReader(io.StringIO(content))
  rows = list(reader)
  assert len(rows) == 10  # All 10 seeded jobs
  assert "title" in reader.fieldnames
  assert "company" in reader.fieldnames
  assert "platform" in reader.fieldnames
  assert "score" in reader.fieldnames
  ```

**Test 2: `test_json_export_downloads_valid_file`**
- Navigate to dashboard
- Trigger download: `with page.expect_download() as download_info: page.locator("#export-json-link").click()`
- Get download, assert filename ends with `.json`
- Read and validate:
  ```python
  content = download.path().read_text()
  data = json.loads(content)
  assert isinstance(data, list)
  assert len(data) == 10
  assert "title" in data[0]
  assert "company" in data[0]
  assert "platform" in data[0]
  ```

**Test 3: `test_filtered_export_contains_subset`**
- Navigate to dashboard
- Filter by platform "dice": select "dice" in platform dropdown, click Filter, wait for networkidle
- The export links include query params from the current filter state (see dashboard.html template -- the export hrefs include `platform={{ filters.platform or '' }}`)
- Click CSV export link (it should now include `&platform=dice` in href)
- Read CSV content
- Assert all rows have platform "dice": `for row in rows: assert row["platform"] == "dice"`
- Assert `len(rows) == 3` (3 dice jobs from seeded_db)

Each test takes `self, page, live_server, seeded_db` as parameters.
  </action>
  <verify>
Run `uv run pytest tests/e2e/test_export.py -m e2e -p no:socket -v` and verify all 3 tests pass.
  </verify>
  <done>CSV export downloads a valid file with correct headers and 10 rows. JSON export downloads a valid file with 10 objects. Filtered CSV export contains only the filtered subset (3 dice jobs).</done>
</task>

<task type="auto">
  <name>Task 3: Fix CI E2E command to disable socket plugin</name>
  <files>.github/workflows/ci.yml</files>
  <action>
The current CI E2E command on line 72 of `.github/workflows/ci.yml` is:
```
uv run pytest -m e2e --tracing=retain-on-failure || true
```

This will fail with `SocketBlockedError` because `pyproject.toml` addopts includes `--disable-socket` and E2E tests need real network access.

Change line 72 to:
```
uv run pytest -m e2e -p no:socket --tracing=retain-on-failure || true
```

The `-p no:socket` flag disables the `pytest-socket` plugin entirely for the E2E run, which is cleaner than relying on `@pytest.mark.enable_socket` markers (the markers work too, but `-p no:socket` ensures no socket-related issues at all including the live server startup and CDN requests within the browser).

Also add `pytest-playwright` to the CI install step. Check whether `uv sync --locked --dev` already covers it (it should, since we added it to pyproject.toml dev dependencies in plan 01). If the lockfile was updated in plan 01, this should just work. No additional CI changes needed for installation.

Verify the CI file is valid YAML after the edit.
  </action>
  <verify>
Read the updated `.github/workflows/ci.yml` and confirm:
1. Line 72 (or equivalent) contains `-p no:socket` in the E2E pytest command
2. The YAML is valid: `uv run python -c "import yaml; yaml.safe_load(open('.github/workflows/ci.yml'))"` (or just visually verify)
  </verify>
  <done>CI E2E command includes `-p no:socket` to prevent SocketBlockedError. The E2E job will successfully run all E2E tests when triggered.</done>
</task>

</tasks>

<verification>
Run the complete E2E test suite to verify all tests pass:
```bash
uv run pytest tests/e2e/ -m e2e -p no:socket -v
```
Expected: All tests pass (2 kanban + 3 export + tests from plan 01).

Verify the full test suite still passes without E2E:
```bash
uv run pytest -v
```
Expected: All existing tests pass, E2E tests are NOT collected.

Verify CI YAML is correct:
```bash
python -c "import yaml; yaml.safe_load(open('.github/workflows/ci.yml'))"
```
Expected: No error.
</verification>

<success_criteria>
- tests/e2e/test_kanban.py has 2 passing tests for kanban load and drag-and-drop
- tests/e2e/test_export.py has 3 passing tests for CSV, JSON, and filtered export
- .github/workflows/ci.yml E2E command includes `-p no:socket`
- `uv run pytest tests/e2e/ -m e2e -p no:socket -v` passes all E2E tests
- `uv run pytest` still excludes E2E tests and all existing tests pass
- Kanban drag-and-drop moves card between columns and persists after reload
- Exported CSV/JSON files contain valid data matching the displayed jobs
</success_criteria>

<output>
After completion, create `.planning/phases/15-e2e-tests/15-02-SUMMARY.md`
</output>
