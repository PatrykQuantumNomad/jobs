---
phase: 05-dashboard-core
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - webapp/db.py
  - webapp/app.py
  - webapp/templates/dashboard.html
  - webapp/templates/partials/job_rows.html
autonomous: true

must_haves:
  truths:
    - "User can type a search query in the dashboard and results filter instantly (debounced 500ms)"
    - "Search matches against title, company, and description text via FTS5"
    - "Search respects active score, platform, and status filters simultaneously"
    - "Table body updates via htmx without full page reload"
    - "Empty search returns all jobs (same as no search)"
  artifacts:
    - path: "webapp/db.py"
      provides: "get_jobs() with search parameter using FTS5 MATCH"
      contains: "jobs_fts MATCH"
    - path: "webapp/app.py"
      provides: "/search endpoint returning partial HTML"
      contains: "def search_jobs"
    - path: "webapp/templates/dashboard.html"
      provides: "Search input with hx-get, hx-trigger, hx-target"
      contains: "hx-get=\"/search\""
    - path: "webapp/templates/partials/job_rows.html"
      provides: "Extracted table body rows for htmx swap"
      min_lines: 10
  key_links:
    - from: "webapp/templates/dashboard.html"
      to: "/search"
      via: "htmx hx-get with debounce"
      pattern: "hx-trigger.*delay:500ms"
    - from: "webapp/app.py"
      to: "webapp/db.py"
      via: "get_jobs(search=q)"
      pattern: "db\\.get_jobs.*search="
    - from: "webapp/db.py"
      to: "jobs_fts"
      via: "FTS5 MATCH query"
      pattern: "jobs_fts MATCH"
---

<objective>
Add text search to the dashboard with htmx active search pattern and FTS5 backend. Extract table body into a partial template for htmx swap reuse across search, bulk actions, and filtering.

Purpose: DASH-01 (text search across title, company, description). The partial template also becomes the shared rendering target for Plans 03 and 04.
Output: Working search box on dashboard, /search endpoint, partial template for table body rows.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-dashboard-core/05-RESEARCH.md
@.planning/phases/05-dashboard-core/05-01-SUMMARY.md

@webapp/db.py
@webapp/app.py
@webapp/templates/dashboard.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add search parameter to get_jobs() and create /search endpoint</name>
  <files>webapp/db.py, webapp/app.py</files>
  <action>
In webapp/db.py:

1. Modify get_jobs() to accept a `search: str | None = None` parameter (add it as the first param after self). Update the function body:
   - Declare `join = ""` at the top alongside where_clauses and params.
   - If search is not None and search.strip() is truthy:
     - Set join = "JOIN jobs_fts ON jobs_fts.rowid = jobs.rowid"
     - Append "jobs_fts MATCH ?" to where_clauses
     - Process the search term: if it does not contain any of `"`, `*`, `AND`, `OR`, `NOT` (FTS5 operators), split into words and add `*` suffix to each for prefix matching. E.g., "kube eng" becomes "kube* eng*". Append the processed term to params.
   - Update the query to include the join: `f"SELECT jobs.* FROM jobs {join} {where} ORDER BY {sort_by} {direction} NULLS LAST"`
   - When search is active and sort_by is "score", also consider FTS5 rank: add `jobs_fts.rank` as a secondary sort. Use: `ORDER BY {sort_by} {direction} NULLS LAST` (keep existing behavior -- FTS5 rank is handled by the JOIN filtering, ranking within score is good enough).

In webapp/app.py:

2. Update the dashboard() route to accept `q: str = Query("")` parameter. Pass it to db.get_jobs(search=q, ...). Also pass `q` into the filters dict as `"q": q`.

3. Add a new GET /search endpoint:
   ```python
   @app.get("/search", response_class=HTMLResponse)
   async def search_jobs(
       request: Request,
       q: str = Query(""),
       score: int | None = Query(None),
       platform: str | None = Query(None),
       status: str | None = Query(None),
       sort: str = Query("score"),
       dir: str = Query("desc"),
   ):
       jobs = db.get_jobs(
           search=q if q else None,
           score_min=score,
           platform=platform,
           status=status,
           sort_by=sort,
           sort_dir=dir,
       )
       return templates.TemplateResponse(
           "partials/job_rows.html",
           {"request": request, "jobs": jobs, "statuses": STATUSES},
       )
   ```
  </action>
  <verify>
```bash
cd /Users/patrykattc/work/jobs && JOBFLOW_TEST_DB=1 python -c "
from webapp import db
# Insert test jobs
db.upsert_job({'id': '1', 'platform': 'indeed', 'title': 'Senior Kubernetes Engineer', 'company': 'Google', 'url': 'http://test', 'description': 'Build cloud infrastructure with K8s'})
db.upsert_job({'id': '2', 'platform': 'dice', 'title': 'Python Developer', 'company': 'Microsoft', 'url': 'http://test2', 'description': 'Write Python code for data pipelines'})

# Test FTS search
results = db.get_jobs(search='kubernetes')
titles = [r['title'] for r in results]
assert 'Senior Kubernetes Engineer' in titles, f'Expected K8s job in {titles}'
assert 'Python Developer' not in titles, f'Did not expect Python job in {titles}'

# Test prefix search
results2 = db.get_jobs(search='kube')
assert len(results2) >= 1, 'Prefix search should find K8s job'

# Test empty search returns all
results3 = db.get_jobs(search='')
assert len(results3) == 2, f'Empty search should return all, got {len(results3)}'

# Test search + filter
results4 = db.get_jobs(search='engineer', platform='indeed')
assert len(results4) == 1

print('ALL SEARCH TESTS PASSED')
"
```
  </verify>
  <done>get_jobs() supports FTS5 search via the `search` parameter. Prefix matching works. Search combines with existing filters. /search endpoint exists and returns partial HTML.</done>
</task>

<task type="auto">
  <name>Task 2: Create partial template and add search UI to dashboard</name>
  <files>webapp/templates/partials/job_rows.html, webapp/templates/dashboard.html</files>
  <action>
1. Create the directory `webapp/templates/partials/` if it does not exist.

2. Create `webapp/templates/partials/job_rows.html` -- extract the table body content from dashboard.html. This partial renders just the `<tr>` rows (no `<table>`, no `<thead>`, no `<tbody>` tag). It expects `jobs` and `statuses` in context:

   ```html
   {% for job in jobs %}
   <tr class="job-row" onclick="window.location='/jobs/{{ job.dedup_key | urlencode }}'">
       <td class="px-4 py-3">
           <div class="flex items-center gap-1">
               {% if job.score %}
               <span class="score-{{ job.score }}">{{ job.score }}</span>
               {% else %}
               <span class="text-gray-300">--</span>
               {% endif %}
               {% if not job.viewed_at %}
               <span class="text-xs px-1.5 py-0.5 rounded bg-green-100 text-green-800 font-semibold">NEW</span>
               {% endif %}
           </div>
           {% if job.score_breakdown %}
           {% set bd = job.score_breakdown | parse_json %}
           <div class="text-xs text-gray-400 mt-0.5 whitespace-nowrap">
               Title +{{ bd.title }} | Tech +{{ bd.tech }} | Remote +{{ bd.remote }} | Salary +{{ bd.salary }}
           </div>
           {% endif %}
       </td>
       <td class="px-4 py-3 font-medium text-gray-900">{{ job.company }}</td>
       <td class="px-4 py-3 text-gray-700">{{ job.title }}</td>
       <td class="px-4 py-3 text-gray-500 hidden md:table-cell">{{ job.location or '\u2014' }}</td>
       <td class="px-4 py-3 text-gray-500 hidden lg:table-cell">
           {% if job.salary_display %}
               {{ job.salary_display }}
           {% endif %}
       </td>
       <td class="px-4 py-3">
           <span class="text-xs px-2 py-0.5 rounded bg-gray-100 text-gray-600">{{ job.platform }}</span>
       </td>
       <td class="px-4 py-3">
           <span class="status-badge status-{{ job.status }}">{{ job.status }}</span>
       </td>
   </tr>
   {% endfor %}
   {% if not jobs %}
   <tr>
       <td colspan="7" class="px-4 py-12 text-center text-gray-400">
           No jobs match your search.
       </td>
   </tr>
   {% endif %}
   ```

3. Update `webapp/templates/dashboard.html`:

   a. Add a search input ABOVE the filter form, inside the filter card. Place it as the first element inside the form, before the Min Score dropdown. Add it as its own div:
      ```html
      <div class="w-full mb-3">
          <label class="text-xs text-gray-500 block mb-1">Search</label>
          <input type="search" name="q" placeholder="Search jobs by title, company, or description..."
                 value="{{ filters.q or '' }}"
                 hx-get="/search"
                 hx-trigger="input changed delay:500ms, keyup[key=='Enter']"
                 hx-target="#job-table-body"
                 hx-swap="innerHTML"
                 hx-include="[name='score'],[name='platform'],[name='status'],[name='sort'],[name='dir']"
                 class="border rounded px-3 py-1.5 text-sm w-full">
      </div>
      ```

   b. Add `id="job-table-body"` to the `<tbody>` element.

   c. Replace the inline row rendering in the `<tbody>` with an include of the partial:
      ```html
      <tbody id="job-table-body" class="divide-y">
          {% include "partials/job_rows.html" %}
      </tbody>
      ```

   d. The empty state message is now inside the partial, so remove the `{% if not jobs %}` block that was previously inline in the tbody.
  </action>
  <verify>
```bash
cd /Users/patrykattc/work/jobs && python -c "
# Check partial template exists
from pathlib import Path
partial = Path('webapp/templates/partials/job_rows.html')
assert partial.exists(), 'Partial template missing'
content = partial.read_text()
assert 'job.dedup_key' in content, 'Partial should reference dedup_key'
assert 'job.score_breakdown' in content, 'Partial should include score breakdown'

# Check dashboard includes partial
dash = Path('webapp/templates/dashboard.html').read_text()
assert 'job-table-body' in dash, 'Dashboard should have job-table-body id'
assert 'hx-get=\"/search\"' in dash, 'Dashboard should have search input'
assert 'include \"partials/job_rows.html\"' in dash, 'Dashboard should include partial'
assert 'hx-include' in dash, 'Search should include filter values'

print('ALL TEMPLATE CHECKS PASSED')
"
```
  </verify>
  <done>Partial template created at webapp/templates/partials/job_rows.html. Dashboard has search input with htmx active search (500ms debounce). Search includes existing filter values via hx-include. Table body uses partial template via Jinja2 include.</done>
</task>

</tasks>

<verification>
1. Start the dashboard: `cd /Users/patrykattc/work/jobs && python -m webapp.app` -- verify no startup errors
2. Navigate to http://127.0.0.1:8000 -- search input visible above filter dropdowns
3. Type a search term -- table body updates after 500ms pause without full page reload
4. Search with active filters -- results respect both search and filters
5. Empty search box -- returns to showing all jobs
</verification>

<success_criteria>
- Dashboard has a search input that filters jobs by title/company/description in real-time
- FTS5 powers the search with prefix matching (typing "kube" finds "Kubernetes")
- Search respects active score/platform/status filters via hx-include
- Partial template extracts table rows for reuse by other htmx endpoints
- DASH-01 requirement fully satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/05-dashboard-core/05-02-SUMMARY.md`
</output>
