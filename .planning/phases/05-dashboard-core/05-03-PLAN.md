---
phase: 05-dashboard-core
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - webapp/app.py
  - webapp/templates/job_detail.html
autonomous: true

must_haves:
  truths:
    - "Job detail page shows a timeline of all activity events in reverse chronological order"
    - "Status changes show old and new status values in the timeline"
    - "Notes additions appear in the timeline"
    - "Discovery event (backfilled) appears as the first historical event"
    - "Changing status on detail page creates an activity log entry"
    - "Job detail status dropdown shows all 9 user-facing statuses"
  artifacts:
    - path: "webapp/app.py"
      provides: "Activity log passed to job_detail template context"
      contains: "get_activity_log"
    - path: "webapp/templates/job_detail.html"
      provides: "Activity timeline section in sidebar"
      contains: "activity_log"
  key_links:
    - from: "webapp/app.py"
      to: "webapp/db.py"
      via: "db.get_activity_log(dedup_key)"
      pattern: "db\\.get_activity_log"
    - from: "webapp/templates/job_detail.html"
      to: "activity_log context variable"
      via: "Jinja2 loop rendering timeline"
      pattern: "for event in activity"
---

<objective>
Add per-job activity timeline to the job detail page, showing all events (discovery, status changes, notes) in reverse chronological order. Update the status dropdown to show the full 9 user-facing statuses.

Purpose: DASH-05 (activity log per job) and DASH-02 (status dropdown with 9 statuses on detail page). The activity logging backend was wired in Plan 01 -- this plan adds the UI.
Output: Job detail page shows activity timeline. Status changes and notes automatically appear in timeline.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-dashboard-core/05-RESEARCH.md
@.planning/phases/05-dashboard-core/05-01-SUMMARY.md

@webapp/app.py
@webapp/templates/job_detail.html
@webapp/db.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pass activity log to job detail template and add mark-viewed activity</name>
  <files>webapp/app.py</files>
  <action>
In webapp/app.py:

1. In the job_detail() route, after fetching the job and before the return, fetch the activity log:
   ```python
   activity = db.get_activity_log(dedup_key)
   ```
   Pass `activity` into the template context dict alongside `job` and `statuses`.

2. In the job_detail() route, when a job is viewed for the first time (the `if job.get("viewed_at") is None:` block), also log a "viewed" activity event:
   ```python
   if job.get("viewed_at") is None:
       db.mark_viewed(dedup_key)
       db.log_activity(dedup_key, "viewed")
   ```

3. In the update_status() route, the activity logging is already handled by db.update_job_status() (wired in Plan 01). No changes needed here -- but verify the route returns the updated status badge HTML. No changes needed.

4. In the update_notes() route, the activity logging is already handled by db.update_job_notes() (wired in Plan 01). No changes needed.
  </action>
  <verify>
```bash
cd /Users/patrykattc/work/jobs && JOBFLOW_TEST_DB=1 python -c "
from webapp import db

# Insert a test job
db.upsert_job({'id': '1', 'platform': 'indeed', 'title': 'Test Engineer', 'company': 'TestCo', 'url': 'http://test', 'description': 'Test'})

# Simulate status change (which should log activity)
db.update_job_status('testco::test engineer', 'saved')
db.update_job_notes('testco::test engineer', 'Great opportunity')

# Fetch activity log
log = db.get_activity_log('testco::test engineer')
types = [e['event_type'] for e in log]
print(f'Event types: {types}')
assert 'discovered' in types, f'Missing discovered event in {types}'
assert 'status_change' in types, f'Missing status_change event in {types}'
assert 'note_added' in types, f'Missing note_added event in {types}'

# Check status_change has old/new values
status_event = next(e for e in log if e['event_type'] == 'status_change')
assert status_event['new_value'] == 'saved', f'Expected saved, got {status_event[\"new_value\"]}'

print('ALL ACTIVITY LOG TESTS PASSED')
"
```
  </verify>
  <done>Activity log fetched and passed to job detail template. First view logs a "viewed" event. Status changes and notes additions automatically create activity entries.</done>
</task>

<task type="auto">
  <name>Task 2: Add activity timeline section to job detail template</name>
  <files>webapp/templates/job_detail.html</files>
  <action>
In webapp/templates/job_detail.html:

1. In the sidebar (the `<div class="space-y-6">` after the main content column), add an "Activity" section BETWEEN the "Notes" section and the "Metadata" section:

   ```html
   <!-- Activity Timeline -->
   <div class="bg-white rounded-lg shadow-sm border p-6">
       <h2 class="text-lg font-semibold text-gray-900 mb-3">Activity</h2>
       {% if activity %}
       <div class="space-y-3">
           {% for event in activity %}
           <div class="flex gap-3 text-sm">
               <div class="flex-shrink-0 w-2 h-2 mt-1.5 rounded-full
                   {% if event.event_type == 'status_change' %}bg-indigo-400
                   {% elif event.event_type == 'discovered' %}bg-green-400
                   {% elif event.event_type == 'note_added' %}bg-yellow-400
                   {% elif event.event_type == 'viewed' %}bg-gray-400
                   {% elif event.event_type == 'applied' %}bg-purple-400
                   {% elif event.event_type == 'scored' %}bg-blue-400
                   {% else %}bg-gray-300
                   {% endif %}"></div>
               <div class="flex-1 min-w-0">
                   <div class="text-gray-700">
                       {% if event.event_type == 'status_change' %}
                           Status changed
                           {% if event.old_value %}from <span class="status-badge status-{{ event.old_value }}">{{ event.old_value }}</span>{% endif %}
                           to <span class="status-badge status-{{ event.new_value }}">{{ event.new_value }}</span>
                       {% elif event.event_type == 'discovered' %}
                           Discovered on {{ event.new_value }}
                       {% elif event.event_type == 'note_added' %}
                           Note updated
                       {% elif event.event_type == 'viewed' %}
                           Viewed for the first time
                       {% elif event.event_type == 'scored' %}
                           Scored: {{ event.new_value }}
                       {% elif event.event_type == 'applied' %}
                           Application submitted
                       {% else %}
                           {{ event.event_type }}
                       {% endif %}
                   </div>
                   <div class="text-xs text-gray-400 mt-0.5">{{ event.created_at }}</div>
               </div>
           </div>
           {% endfor %}
       </div>
       {% else %}
       <p class="text-sm text-gray-400">No activity recorded.</p>
       {% endif %}
   </div>
   ```

2. The status dropdown in the Status section already uses `{% for s in statuses %}` which loops over the STATUSES list from app.py. Since Plan 01 already updated STATUSES to 11 values, the dropdown will automatically show all statuses. No template change needed for this -- verify it works.

3. Make the status display labels more human-readable by adding a Jinja2 filter or inline replacement. Add display-friendly labels by replacing underscores with spaces and title-casing in the status badge text. In the Status section's display and dropdown, use `{{ s | replace('_', ' ') }}` for display text in the select options:
   ```html
   {% for s in statuses %}
   <option value="{{ s }}" {% if job.status == s %}selected{% endif %}>{{ s | replace('_', ' ') | title }}</option>
   {% endfor %}
   ```
   Also update the status badge display:
   ```html
   <span class="status-badge status-{{ job.status }}">{{ job.status | replace('_', ' ') }}</span>
   ```

4. Apply the same human-readable status display in the activity timeline where status badges are shown.
  </action>
  <verify>
```bash
cd /Users/patrykattc/work/jobs && python -c "
from pathlib import Path
content = Path('webapp/templates/job_detail.html').read_text()
assert 'activity' in content.lower(), 'Missing activity section'
assert 'event.event_type' in content, 'Missing event_type reference'
assert 'status_change' in content, 'Missing status_change handling'
assert 'discovered' in content, 'Missing discovered handling'
assert 'note_added' in content, 'Missing note_added handling'
assert 'event.created_at' in content, 'Missing timestamp display'
# Check human-readable status display
assert \"replace('_', ' ')\" in content, 'Missing underscore replacement for status display'
print('ALL TEMPLATE CHECKS PASSED')
"
```
  </verify>
  <done>Job detail page has activity timeline showing all events with color-coded dots, human-readable labels, and timestamps. Status dropdown shows all 9 user-facing statuses with human-readable labels (e.g., "Phone Screen" not "phone_screen").</done>
</task>

</tasks>

<verification>
1. Navigate to a job detail page -- activity timeline visible in sidebar with at least a "discovered" event
2. Change the job's status -- new "status_change" event appears showing old and new status
3. Save a note -- "note_added" event appears in timeline
4. Status dropdown shows 11 options with human-readable labels (spaces, title case)
5. Activity events are in reverse chronological order (newest first)
</verification>

<success_criteria>
- Every job has at least a "discovered" activity entry (backfilled from migration)
- Status changes create activity log entries with old/new values
- Notes create activity log entries
- Timeline renders with color-coded event types and timestamps
- Status dropdown shows all 9 user-facing statuses with readable labels
- DASH-02 (status workflow on detail page) and DASH-05 (activity log) satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/05-dashboard-core/05-03-SUMMARY.md`
</output>
