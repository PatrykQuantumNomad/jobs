---
phase: 04-scheduled-automation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - config.py
  - config.yaml
  - orchestrator.py
  - platforms/mixins.py
  - platforms/indeed.py
  - scheduler.py
autonomous: true

must_haves:
  truths:
    - "ScheduleConfig in config.py accepts enabled (bool), hour (0-23), minute (0-59), and optional weekdays (0-6 list) with Pydantic validation"
    - "config.yaml schedule section populated with enabled: false, hour: 8, minute: 0 defaults (was empty {})"
    - "python orchestrator.py --scheduled runs the pipeline headless with zero input() calls -- phase_4_apply is skipped, expired browser sessions raise RuntimeError instead of blocking, wait_for_human raises RuntimeError instead of blocking"
    - "python scheduler.py install generates a valid launchd plist at ~/Library/LaunchAgents/com.jobflow.pipeline.plist with absolute paths (no shell variables) and loads it via launchctl bootstrap"
    - "python scheduler.py uninstall removes the plist and unloads via launchctl bootout"
    - "python scheduler.py status reports whether the launchd job is loaded or not"
  artifacts:
    - path: "scheduler.py"
      provides: "CLI tool for launchd plist generation, install, uninstall, status"
      exports: ["main"]
    - path: "config.py"
      provides: "Populated ScheduleConfig model replacing the empty placeholder"
      contains: "class ScheduleConfig"
    - path: "config.yaml"
      provides: "Schedule section with real defaults"
      contains: "schedule:"
    - path: "orchestrator.py"
      provides: "--scheduled CLI flag, unattended mode skipping phase_4_apply"
      contains: "--scheduled"
  key_links:
    - from: "scheduler.py"
      to: "config.py"
      via: "Reads ScheduleConfig to determine hour/minute/weekdays for plist generation"
      pattern: "get_settings.*schedule"
    - from: "scheduler.py"
      to: "orchestrator.py"
      via: "Plist ProgramArguments invokes orchestrator.py --scheduled"
      pattern: "orchestrator.py.*--scheduled"
    - from: "orchestrator.py"
      to: "platforms/mixins.py"
      via: "Orchestrator sets _unattended on platform instances; mixins check it before input()"
      pattern: "_unattended"
---

<objective>
Create the scheduler configuration model, unattended pipeline mode, and launchd management CLI.

Purpose: This is the foundation for scheduled automation -- the ScheduleConfig model defines the schedule, the --scheduled flag makes the pipeline safe to run without a terminal, and scheduler.py generates and manages the macOS launchd agent. Without this, scheduled runs would hang on input() calls or crash in headless mode.
Output: Working `scheduler.py` CLI (install/uninstall/status), populated ScheduleConfig model, --scheduled flag on orchestrator, all input() sites guarded.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-scheduled-automation/04-RESEARCH.md

@config.py
@config.yaml
@orchestrator.py
@platforms/mixins.py
@platforms/indeed.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Populate ScheduleConfig model and config.yaml, add --scheduled flag and guard all input() sites</name>
  <files>config.py, config.yaml, orchestrator.py, platforms/mixins.py, platforms/indeed.py</files>
  <action>
**config.py** -- Replace the empty `ScheduleConfig` placeholder (line 110-111) with a real model:

```python
class ScheduleConfig(BaseModel):
    """Top-level ``schedule:`` section of config.yaml."""
    enabled: bool = False
    hour: int = Field(default=8, ge=0, le=23)
    minute: int = Field(default=0, ge=0, le=59)
    weekdays: list[int] | None = Field(
        default=None,
        description="Days of week to run (0=Sun, 1=Mon, ..., 6=Sat). None = daily.",
    )

    @field_validator("weekdays")
    @classmethod
    def validate_weekdays(cls, v: list[int] | None) -> list[int] | None:
        if v is not None:
            for day in v:
                if not (0 <= day <= 6):
                    raise ValueError(f"Weekday must be 0-6, got {day}")
        return v
```

Add `from pydantic import field_validator` to the imports if not already present.

**config.yaml** -- Replace `schedule: {}` with populated defaults:

```yaml
schedule:
  enabled: false       # Set to true and run 'python scheduler.py install'
  hour: 8              # Hour (0-23) to run the pipeline
  minute: 0            # Minute (0-59) to run the pipeline
  # weekdays: [1,2,3,4,5]  # Optional: limit to specific days (0=Sun, 6=Sat)
                            # Omit for daily execution
```

**orchestrator.py** -- Three changes:

1. Add `--scheduled` argument to the CLI parser (after the existing `--headed` and `--validate` args):
```python
parser.add_argument(
    "--scheduled",
    action="store_true",
    help="Unattended mode: headless, no input prompts, logs run history",
)
```

2. Pass `scheduled` to `Orchestrator.__init__`:
```python
# In __init__, add parameter:
def __init__(self, headless: bool = True, scheduled: bool = False) -> None:
    ...
    self.scheduled = scheduled
    if scheduled:
        self.headless = True  # Force headless in scheduled mode
```

3. Guard `phase_4_apply` -- add at the top of the method:
```python
def phase_4_apply(self) -> None:
    if self.scheduled:
        print("  Scheduled mode: skipping apply phase (requires human approval)")
        return
    # ... existing code unchanged ...
```

4. In `_login_platform`, set `_unattended` on platform instances before calling login:
```python
def _login_platform(self, name: str, info: PlatformInfo) -> None:
    pw, ctx = None, None
    try:
        pw, ctx = get_browser_context(name, headless=self.headless)
        platform = info.cls()
        platform.init(ctx)
        platform._unattended = self.scheduled  # Propagate unattended flag
        with platform:
            platform.login()
    ...
```

5. Similarly in `_search_platform`, set `_unattended` after construction:
```python
platform = info.cls()
# ... after init() call ...
platform._unattended = self.scheduled
```

6. Update the CLI entry point to pass `scheduled`:
```python
Orchestrator(headless=not args.headed, scheduled=args.scheduled).run(platforms=args.platforms)
```

**platforms/indeed.py** -- Guard the `input()` call in `login()` (around line 74). Before the `input("  Press ENTER after logging in > ")` line, add:
```python
if getattr(self, '_unattended', False):
    raise RuntimeError(
        "Indeed session expired. Run the pipeline manually (without --scheduled) to re-authenticate."
    )
```

**platforms/mixins.py** -- Guard `wait_for_human()` (line 85). Before the `return input(...)` line, add:
```python
if getattr(self, '_unattended', False):
    raise RuntimeError(
        f"Human input required but running in unattended mode: {message}"
    )
```
  </action>
  <verify>
Run: `python -c "
from config import get_settings, reset_settings
reset_settings()
s = get_settings()
assert s.schedule.enabled == False
assert s.schedule.hour == 8
assert s.schedule.minute == 0
assert s.schedule.weekdays is None
print(f'ScheduleConfig OK: enabled={s.schedule.enabled}, hour={s.schedule.hour}, minute={s.schedule.minute}')
"`

Run: `python orchestrator.py --help | grep -A2 scheduled` -- should show the --scheduled flag

Run: `python -c "
from platforms.mixins import BrowserPlatformMixin
m = BrowserPlatformMixin()
m._unattended = True
m.platform_name = 'test'
try:
    m.wait_for_human('test message')
    assert False, 'Should have raised RuntimeError'
except RuntimeError as e:
    assert 'unattended' in str(e).lower()
    print(f'Mixin guard OK: {e}')
"`
  </verify>
  <done>ScheduleConfig model validates hour/minute/weekdays. config.yaml has real schedule section. --scheduled flag forces headless and skips phase_4_apply. All 3 input() sites guarded: orchestrator apply, indeed login, mixins wait_for_human.</done>
</task>

<task type="auto">
  <name>Task 2: Create scheduler.py with plist generation, install, uninstall, and status commands</name>
  <files>scheduler.py</files>
  <action>
Create `scheduler.py` at project root. This is a standalone CLI tool for managing the launchd scheduled job.

**Structure:**

1. Constants:
   - `LABEL = "com.jobflow.pipeline"`
   - `PLIST_DEST = Path.home() / "Library" / "LaunchAgents" / f"{LABEL}.plist"`

2. `generate_plist(settings) -> dict` -- Build the launchd plist dict:
   - Read `settings.schedule` for `hour`, `minute`, `weekdays`
   - `ProgramArguments`: absolute path to `.venv/bin/python` (resolve from `sys.executable`), absolute path to `orchestrator.py`, `"--scheduled"`
   - `WorkingDirectory`: absolute path to project root (resolve from `__file__`)
   - `StartCalendarInterval`: If weekdays is None, single dict `{"Hour": hour, "Minute": minute}`. If weekdays is a list, create a list of dicts, one per day: `[{"Hour": hour, "Minute": minute, "Weekday": day} for day in weekdays]`
   - `StandardOutPath`: `{project_root}/job_pipeline/logs/pipeline.log`
   - `StandardErrorPath`: `{project_root}/job_pipeline/logs/pipeline.err`
   - `EnvironmentVariables`: `{"PATH": "/usr/bin:/usr/local/bin:/opt/homebrew/bin"}`
   - `ProcessType`: `"Background"`
   - All paths MUST be absolute strings (no `~`, no `$HOME`, no shell variables)

3. `write_plist(plist_data: dict, dest: Path) -> None` -- Write using `plistlib.dump()`

4. `install_schedule()`:
   - Load settings via `get_settings()`
   - Check `settings.schedule.enabled` -- if False, print error and exit
   - Generate plist
   - Create logs directory: `(project_root / "job_pipeline" / "logs").mkdir(parents=True, exist_ok=True)`
   - Write plist to `PLIST_DEST`
   - Run `launchctl bootstrap gui/{uid} {plist_path}` via `subprocess.run(check=True)`
   - Print success message with schedule details

5. `uninstall_schedule()`:
   - Run `launchctl bootout gui/{uid} {plist_path}` via `subprocess.run(check=False)` (may not be loaded)
   - Remove plist file: `PLIST_DEST.unlink(missing_ok=True)`
   - Print success message

6. `show_status()`:
   - Run `launchctl list {LABEL}` with `capture_output=True`
   - If returncode == 0: print "loaded" with parsed exit status
   - If returncode != 0: print "not loaded"

7. `main()`:
   - `argparse` with subcommands: `install`, `uninstall`, `status`
   - Route to appropriate function
   - `if __name__ == "__main__": main()`

**Important constraints:**
- Use `sys.executable` to get the current Python interpreter path (which will be the venv python)
- Use `Path(__file__).parent.resolve()` for project root
- Use `os.getuid()` for the UID in launchctl commands
- Use `plistlib.dump()` (NOT the deprecated `writePlist`)
- Add `ensure_directories()` call before install to create `job_pipeline/logs/`
  </action>
  <verify>
Run: `python scheduler.py --help` -- should show install/uninstall/status subcommands

Run: `python -c "
import sys, plistlib
from pathlib import Path
sys.path.insert(0, '.')
from scheduler import generate_plist, LABEL
from config import get_settings, reset_settings
reset_settings()
settings = get_settings()
plist = generate_plist(settings)
assert plist['Label'] == LABEL
assert '--scheduled' in plist['ProgramArguments']
assert not any('\$' in str(v) or '~' in str(v) for v in [
    plist['WorkingDirectory'],
    plist['StandardOutPath'],
    plist['StandardErrorPath'],
] + plist['ProgramArguments']), 'Contains shell variables!'
# Verify all paths are absolute
for p in plist['ProgramArguments']:
    if p.startswith('/') or p.startswith('--'):
        continue
    assert False, f'Non-absolute path in ProgramArguments: {p}'
assert plist['WorkingDirectory'].startswith('/')
print(f'Plist OK: label={plist[\"Label\"]}')
print(f'  Python: {plist[\"ProgramArguments\"][0]}')
print(f'  Script: {plist[\"ProgramArguments\"][1]}')
print(f'  CWD: {plist[\"WorkingDirectory\"]}')
print(f'  Schedule: {plist[\"StartCalendarInterval\"]}')
"`

Run: `python scheduler.py status` -- should print "not loaded" (since we haven't installed)
  </verify>
  <done>scheduler.py generates valid launchd plist with absolute paths, supports install/uninstall/status subcommands. Plist uses venv Python path, --scheduled flag, correct working directory, and log file paths. StartCalendarInterval supports both daily and weekday-specific schedules.</done>
</task>

</tasks>

<verification>
1. `python -c "from config import get_settings, reset_settings; reset_settings(); s = get_settings(); print(s.schedule.enabled, s.schedule.hour, s.schedule.minute)"` -- prints `False 8 0`
2. `python orchestrator.py --help` shows `--scheduled` flag
3. `python scheduler.py status` runs without error
4. `python scheduler.py --help` shows install/uninstall/status subcommands
5. Generated plist contains only absolute paths (no `~`, `$HOME`, shell variables)
6. All three `input()` call sites are guarded by `_unattended` check that raises RuntimeError
7. `--scheduled` flag forces headless mode and skips phase_4_apply
</verification>

<success_criteria>
- ScheduleConfig validates hour (0-23), minute (0-59), weekdays (0-6 list or None)
- config.yaml schedule section has real defaults (not empty {})
- orchestrator.py --scheduled skips apply phase and forces headless
- All input() calls in orchestrator, indeed.py, mixins.py raise RuntimeError in unattended mode
- scheduler.py install generates a valid plist and loads via launchctl bootstrap
- scheduler.py uninstall removes plist and unloads via launchctl bootout
- scheduler.py status reports loaded/not loaded
- All paths in generated plist are absolute (no shell variable expansion needed)
</success_criteria>

<output>
After completion, create `.planning/phases/04-scheduled-automation/04-01-SUMMARY.md`
</output>
