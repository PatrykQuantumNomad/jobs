---
phase: 12-web-api-integration-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/webapp/test_endpoints.py
autonomous: true

must_haves:
  truths:
    - "GET / returns 200 with HTML containing job data when database has jobs"
    - "GET / with score filter returns only jobs matching the minimum score"
    - "GET / with platform filter returns only jobs from that platform"
    - "GET / with status filter returns only jobs with that status"
    - "GET / with wrong filter values returns empty results, not errors"
    - "GET /jobs/{dedup_key} returns 200 with full job detail including description and activity log"
    - "GET /jobs/{nonexistent} returns 404"
    - "POST /jobs/{key}/status changes job status in DB and returns status badge HTML"
    - "POST /jobs/{key}/status sets HX-Trigger header to 'statsChanged'"
    - "POST /jobs/{key}/notes persists notes text and returns confirmation HTML"
    - "GET /search returns HTML partial with filtered job rows"
    - "GET /search with q= parameter returns only FTS5-matched jobs"
  artifacts:
    - path: "tests/webapp/test_endpoints.py"
      provides: "WEB-01, WEB-02, WEB-03, WEB-08: Dashboard, detail, status, and search endpoint integration tests"
      contains: "class TestDashboardEndpoint"
  key_links:
    - from: "tests/webapp/test_endpoints.py"
      to: "webapp/app.py"
      via: "TestClient(app) exercising FastAPI routes"
      pattern: "client.get|client.post"
    - from: "tests/webapp/test_endpoints.py"
      to: "webapp/db.py"
      via: "Direct db_module calls for seeding and verification"
      pattern: "db_module.upsert_job|db_module.get_job"
---

<objective>
Write integration tests for the core FastAPI web endpoints: dashboard with filtering (WEB-01), job detail (WEB-02), status and notes update (WEB-03), and search (WEB-08).

Purpose: These tests verify the HTTP layer that sits between the user's browser and the database -- that query parameters are correctly translated into DB filters, that job detail pages load with full metadata, that status updates persist and trigger htmx events, and that FTS5 search works through the API layer.

Output: tests/webapp/test_endpoints.py with test classes covering dashboard filtering, job detail, status/notes updates, and search endpoints.
</objective>

<execution_context>
@/Users/patrykattc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrykattc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-web-api-integration-tests/12-RESEARCH.md
@webapp/app.py
@webapp/db.py
@tests/conftest.py
@tests/webapp/conftest.py
@tests/webapp/test_db.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tests/webapp/test_endpoints.py with dashboard and search endpoint tests (WEB-01, WEB-08)</name>
  <files>tests/webapp/test_endpoints.py</files>
  <action>
Create `tests/webapp/test_endpoints.py` with integration tests. Mark all test classes with `@pytest.mark.integration`.

**Test helpers** (module-level, reuse pattern from `tests/webapp/test_db.py`):

```python
import webapp.db as db_module

def _make_job_dict(company, title, platform="indeed", **kwargs) -> dict:
    # Builds minimal valid job dict for upsert_job(). Same pattern as test_db.py.
    # Required fields: platform, title, company, url, dedup_key, status
    # Compute dedup_key from company+title normalization

def _compute_dedup_key(company, title) -> str:
    # Replicates dedup_key normalization: f"{company}::{title}".lower().strip()
```

**class TestDashboardEndpoint (WEB-01):**

- `test_dashboard_returns_200_empty_db(self, client)`: `client.get("/")` returns 200. Response is HTML. (Tests the route works even with no jobs.)
- `test_dashboard_shows_jobs(self, client, db_with_jobs)`: `client.get("/")` returns 200. Assert job titles from `db_with_jobs` appear in `response.text` (e.g., "Principal Engineer" is in the response).
- `test_filter_by_score_min(self, client)`: Insert 2 jobs with scores 3 and 5 via `db_module.upsert_job()`. GET `/?score=5`. Assert 200. Assert the score-5 job title appears in response. Assert the score-3 job title does NOT appear.
- `test_filter_by_platform(self, client)`: Insert 2 jobs on "indeed" and "dice". GET `/?platform=dice`. Assert 200. Assert only the dice job title appears.
- `test_filter_by_status(self, client)`: Insert 2 jobs. Set one to "applied" via `db_module.update_job_status()`. GET `/?status=applied`. Assert 200. Assert only the applied job appears.
- `test_filter_wrong_score_returns_empty(self, client)`: Insert a job with score=3. GET `/?score=5`. Assert 200. Assert the job title does NOT appear. (Wrong filter returns empty, not error.)
- `test_filter_wrong_platform_returns_empty(self, client)`: Insert a job on "indeed". GET `/?platform=remoteok`. Assert 200. Assert the job title does NOT appear.
- `test_sort_by_score_desc(self, client)`: Insert 2 jobs with scores 3 and 5. GET `/?sort=score&dir=desc`. Assert 200. Assert score-5 job appears before score-3 job in response.text (use `response.text.index()` to compare positions).
- `test_dashboard_contains_filter_controls(self, client)`: GET `/`. Assert 200. Assert response contains form elements or filter-related strings (e.g., "score", "platform", "status" appear in the HTML).

**class TestSearchEndpoint (WEB-08):**

- `test_search_returns_200(self, client)`: GET `/search`. Assert 200.
- `test_search_returns_partial_html(self, client, db_with_jobs)`: GET `/search`. Assert 200. Assert response is HTML (not a full page -- it's a partial for htmx swap, so it should NOT contain `<!DOCTYPE` or `<html>`).
- `test_search_filters_by_query(self, client)`: Insert 2 jobs -- one with title "Kubernetes Engineer", one with title "Python Developer". GET `/search?q=kubernetes`. Assert "Kubernetes Engineer" appears in response. Assert "Python Developer" does NOT appear.
- `test_search_with_score_filter(self, client)`: Insert 2 jobs with "kubernetes" in description -- one score=3, one score=5. GET `/search?q=kubernetes&score=5`. Assert only the score-5 job appears.
- `test_search_empty_query_returns_all(self, client)`: Insert 2 jobs. GET `/search?q=`. Assert both job titles appear in response.

**Important implementation notes:**
- Import `import webapp.db as db_module` (consistent with test_db.py pattern).
- The `client` fixture from `tests/webapp/conftest.py` provides `TestClient(app)`.
- The `_fresh_db` autouse fixture ensures a clean database per test.
- All responses are HTML. Use `response.text` with `in` assertions, not `response.json()`.
- For score filtering, the dashboard passes `score_min` to `db.get_jobs()`, so `/?score=5` means "jobs with score >= 5".
- The search endpoint at `/search` returns `partials/job_rows.html` (an HTML partial), not a full page.
  </action>
  <verify>
Run: `uv run pytest tests/webapp/test_endpoints.py -v --tb=short -m integration` -- all tests pass.
Run: `uv run pytest tests/webapp/test_endpoints.py -v --tb=short 2>&1 | grep -c "PASSED"` -- expect 14 passed tests.
  </verify>
  <done>TestDashboardEndpoint has 9 tests covering: empty DB 200, jobs visible, score/platform/status filtering, wrong filters return empty, sort ordering, filter controls in HTML. TestSearchEndpoint has 5 tests covering: 200 response, partial HTML (not full page), FTS5 query filtering, combined search+score filter, empty query returns all. All marked @pytest.mark.integration.</done>
</task>

<task type="auto">
  <name>Task 2: Add job detail, status update, and notes update tests (WEB-02, WEB-03)</name>
  <files>tests/webapp/test_endpoints.py</files>
  <action>
Append test classes to the existing `tests/webapp/test_endpoints.py` file created in Task 1.

**class TestJobDetailEndpoint (WEB-02):**

- `test_detail_returns_200(self, client)`: Insert a job. GET `/jobs/{dedup_key}`. Assert 200. Assert job title and company appear in response.
- `test_detail_shows_description(self, client)`: Insert a job with description "Expert in Kubernetes and cloud infrastructure". GET `/jobs/{dedup_key}`. Assert description text appears in response.
- `test_detail_shows_activity_log(self, client)`: Insert a job (which auto-logs "discovered" event). GET `/jobs/{dedup_key}`. Assert "discovered" appears in response (from activity log rendering).
- `test_detail_marks_job_as_viewed(self, client)`: Insert a job. Verify `get_job(key)["viewed_at"]` is None. GET `/jobs/{dedup_key}`. Verify `get_job(key)["viewed_at"]` is NOT None after the request.
- `test_detail_nonexistent_returns_404(self, client)`: GET `/jobs/nonexistent::key`. Assert status_code == 404.
- `test_detail_with_special_chars_in_key(self, client)`: Insert a job where company="Google Inc." and title="Staff Engineer (Remote)". GET `/jobs/{dedup_key}`. Assert 200. (Tests URL encoding of dedup keys with spaces and special chars.)

**class TestStatusUpdateEndpoint (WEB-03):**

- `test_status_update_returns_200(self, client)`: Insert a job. POST `/jobs/{key}/status` with `data={"status": "applied"}`. Assert 200.
- `test_status_update_changes_db(self, client)`: Insert a job. POST `/jobs/{key}/status` with `data={"status": "saved"}`. Verify `db_module.get_job(key)["status"] == "saved"`.
- `test_status_update_returns_badge_html(self, client)`: Insert a job. POST `/jobs/{key}/status` with `data={"status": "applied"}`. Assert `"status-badge"` in response.text. Assert `"Applied"` in response.text (title-cased label).
- `test_status_update_sets_hx_trigger(self, client)`: Insert a job. POST `/jobs/{key}/status` with `data={"status": "applied"}`. Assert `response.headers["HX-Trigger"] == "statsChanged"`.
- `test_status_update_logs_activity(self, client)`: Insert a job. POST `/jobs/{key}/status` with `data={"status": "scored"}`. Check `db_module.get_activity_log(key)`. Verify a "status_change" entry exists with `new_value == "scored"`.
- `test_applied_status_sets_applied_date(self, client)`: Insert a job. POST `/jobs/{key}/status` with `data={"status": "applied"}`. Verify `db_module.get_job(key)["applied_date"]` is not None.

**class TestNotesUpdateEndpoint (WEB-03):**

- `test_notes_update_returns_200(self, client)`: Insert a job. POST `/jobs/{key}/notes` with `data={"notes": "Great match for K8s role"}`. Assert 200.
- `test_notes_update_persists(self, client)`: Insert a job. POST `/jobs/{key}/notes` with `data={"notes": "Follow up next week"}`. Verify `db_module.get_job(key)["notes"] == "Follow up next week"`.
- `test_notes_update_returns_confirmation(self, client)`: Insert a job. POST `/jobs/{key}/notes` with `data={"notes": "test"}`. Assert `"Saved"` in response.text.
- `test_notes_update_logs_activity(self, client)`: Insert a job. POST `/jobs/{key}/notes` with `data={"notes": "Important role"}`. Check activity log. Verify a "note_added" entry exists.

**Important implementation notes:**
- POST endpoints use `data=` keyword (form data), NOT `json=`. Using `json=` will cause 422 errors.
- The status endpoint at `/jobs/{key}/status` expects `Form(...)` with `status` field.
- The notes endpoint at `/jobs/{key}/notes` expects `Form(...)` with `notes` field.
- For detail endpoint, the dedup_key may contain spaces and special chars -- TestClient handles URL encoding.
- The `HX-Trigger` header check is important -- htmx clients depend on this for dashboard stats refresh.
  </action>
  <verify>
Run: `uv run pytest tests/webapp/test_endpoints.py -v --tb=short -m integration` -- all tests pass (14 from Task 1 + 16 from Task 2 = 30 total).
Run: `uv run pytest tests/ -v --tb=short -q` -- all existing tests still pass (no regressions).
  </verify>
  <done>TestJobDetailEndpoint has 6 tests covering: 200 response, description visible, activity log visible, viewed_at auto-set, 404 for nonexistent, special chars in dedup key. TestStatusUpdateEndpoint has 6 tests covering: 200 response, DB persistence, badge HTML, HX-Trigger header, activity logging, applied_date auto-set. TestNotesUpdateEndpoint has 4 tests covering: 200 response, notes persistence, confirmation HTML, activity logging. All marked @pytest.mark.integration.</done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/webapp/test_endpoints.py -v --tb=short` -- all 30 tests pass
2. `uv run pytest tests/webapp/test_endpoints.py -m integration -v` -- all tests are correctly marked as integration
3. `uv run pytest tests/ -v --tb=short -q` -- all existing tests still pass (no regressions)
</verification>

<success_criteria>
- tests/webapp/test_endpoints.py has TestDashboardEndpoint with 9 tests for filtering and rendering
- TestSearchEndpoint has 5 tests for FTS5 search through the API layer
- TestJobDetailEndpoint has 6 tests for detail page rendering and metadata
- TestStatusUpdateEndpoint has 6 tests for status changes including HX-Trigger header
- TestNotesUpdateEndpoint has 4 tests for notes persistence and activity logging
- All tests pass with `uv run pytest tests/webapp/test_endpoints.py -v`
- All tests marked with `@pytest.mark.integration`
- POST endpoints tested with `data=` (form encoding), not `json=`
</success_criteria>

<output>
After completion, create `.planning/phases/12-web-api-integration-tests/12-01-SUMMARY.md`
</output>
