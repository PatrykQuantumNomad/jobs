---
phase: 12-web-api-integration-tests
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/platforms/test_remoteok.py
  - tests/platforms/test_registry.py
autonomous: true

must_haves:
  truths:
    - "RemoteOKPlatform.search() with mocked API response returns parsed Job objects with correct title, company, location, salary_min, salary_max, url, and tags"
    - "RemoteOK parser skips index 0 (metadata) and only parses job entries starting at index 1"
    - "RemoteOK parser converts epoch timestamp to ISO-format posted_date"
    - "RemoteOK parser sets platform to 'remoteok' on all parsed jobs"
    - "RemoteOK parser returns None (skips) for entries missing position, company, or url"
    - "RemoteOK parser handles salary_min=0 and salary_max=0 as None"
    - "RemoteOK search() returns empty list on HTTP error (not exception)"
    - "RemoteOK search() returns empty list on malformed JSON response"
    - "RemoteOK search() returns empty list on empty API response"
    - "Platform registry contains 'indeed', 'dice', and 'remoteok' after auto-discovery"
    - "Each registered platform has correct metadata: name, platform_type, and capabilities"
    - "RemoteOK satisfies APIPlatform protocol (isinstance check passes)"
    - "Indeed and Dice satisfy BrowserPlatform protocol (isinstance check passes)"
    - "get_platform() raises KeyError for unregistered platform keys"
    - "get_platforms_by_type('browser') returns only browser platforms, get_platforms_by_type('api') returns only API platforms"
  artifacts:
    - path: "tests/platforms/test_remoteok.py"
      provides: "API-01, API-02: RemoteOK response parsing and error handling tests"
      contains: "class TestRemoteOKParsing"
    - path: "tests/platforms/test_registry.py"
      provides: "API-03, API-04: Platform registry discovery and protocol compliance tests"
      contains: "class TestPlatformRegistry"
  key_links:
    - from: "tests/platforms/test_remoteok.py"
      to: "platforms/remoteok.py"
      via: "RemoteOKPlatform instantiation and search() with respx mocking"
      pattern: "RemoteOKPlatform.*search"
    - from: "tests/platforms/test_registry.py"
      to: "platforms/registry.py"
      via: "get_all_platforms, get_platform, get_platforms_by_type"
      pattern: "get_all_platforms|get_platform|get_platforms_by_type"
    - from: "tests/platforms/test_registry.py"
      to: "platforms/protocols.py"
      via: "isinstance checks against BrowserPlatform and APIPlatform"
      pattern: "isinstance.*BrowserPlatform|isinstance.*APIPlatform"
---

<objective>
Write integration tests for RemoteOK API response parsing (API-01, API-02) and platform registry discovery with protocol compliance (API-03, API-04).

Purpose: These tests verify that the platform layer correctly parses external API responses into Job models and gracefully handles error conditions, and that the plugin architecture successfully discovers all platforms with valid protocol implementations. This ensures platform code works correctly with mocked external dependencies.

Output: tests/platforms/test_remoteok.py and tests/platforms/test_registry.py with integration tests.
</objective>

<execution_context>
@/Users/patrykattc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrykattc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-web-api-integration-tests/12-RESEARCH.md
@platforms/remoteok.py
@platforms/registry.py
@platforms/protocols.py
@platforms/__init__.py
@tests/platforms/conftest.py
@tests/conftest.py
@tests/fixtures/test_config.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tests/platforms/test_remoteok.py with parsing and error handling tests (API-01, API-02)</name>
  <files>tests/platforms/test_remoteok.py</files>
  <action>
Create `tests/platforms/test_remoteok.py` with integration tests for RemoteOK API response parsing and error handling. Mark all test classes with `@pytest.mark.integration`.

**Critical setup:** Every test that calls `RemoteOKPlatform.search()` MUST first call `get_settings("tests/fixtures/test_config.yaml")` to load the test configuration. The `_reset_settings` autouse fixture clears the singleton before each test, so this must be done per-test (or in a class-level fixture). The `mock_remoteok_api` fixture from `tests/platforms/conftest.py` provides a respx mock for the RemoteOK API.

**Helper fixture (inside the test file or as a local fixture):**

```python
from config import get_settings
from models import SearchQuery
from platforms.remoteok import RemoteOKPlatform

@pytest.fixture
def remoteok_platform():
    """Provide a configured RemoteOKPlatform instance with test config loaded."""
    get_settings("tests/fixtures/test_config.yaml")
    platform = RemoteOKPlatform()
    platform.init()
    return platform
```

**class TestRemoteOKParsing (API-01):**

- `test_search_returns_jobs(self, mock_remoteok_api, remoteok_platform)`: Call `platform.search(SearchQuery(query="python kubernetes", platform="remoteok"))`. Assert result is a list with at least 1 job. (The mock returns 2 jobs, both have "python" or "kubernetes" tags.)
- `test_parsed_job_has_correct_title(self, mock_remoteok_api, remoteok_platform)`: Search. Find job with id "12345". Assert `job.title == "Senior Platform Engineer"`.
- `test_parsed_job_has_correct_company(self, mock_remoteok_api, remoteok_platform)`: Assert `job.company == "TestCorp"`.
- `test_parsed_job_has_correct_platform(self, mock_remoteok_api, remoteok_platform)`: Assert `job.platform == "remoteok"` for all returned jobs.
- `test_parsed_job_has_correct_location(self, mock_remoteok_api, remoteok_platform)`: Assert `job.location == "Remote"`.
- `test_parsed_job_has_salary(self, mock_remoteok_api, remoteok_platform)`: Assert `job.salary_min == 200000` and `job.salary_max == 300000`.
- `test_parsed_job_has_url(self, mock_remoteok_api, remoteok_platform)`: Assert `job.url == "https://remoteok.com/remote-jobs/12345"`.
- `test_parsed_job_has_apply_url(self, mock_remoteok_api, remoteok_platform)`: Assert `job.apply_url == "https://testcorp.com/careers/12345"`.
- `test_parsed_job_has_tags(self, mock_remoteok_api, remoteok_platform)`: Assert `job.tags == ["python", "kubernetes", "docker"]`.
- `test_parsed_job_has_posted_date(self, mock_remoteok_api, remoteok_platform)`: Assert `job.posted_date` is not None. Assert it is an ISO-format string containing "2026" (epoch 1707350400 converts to 2024, but the mock sets this -- verify it is a valid ISO datetime string).
- `test_parsed_job_has_description(self, mock_remoteok_api, remoteok_platform)`: Assert `job.description` contains "platform engineer" (from the HTML description in the mock).
- `test_skips_metadata_at_index_zero(self, mock_remoteok_api, remoteok_platform)`: The mock response has metadata at index 0. Search results should NOT contain any entry with "legal" as a field. All returned jobs should have valid titles.
- `test_relative_url_gets_prefix(self, remoteok_platform)`: Test `_parse()` directly with an entry where `url="/remote-jobs/99999"`. Assert the parsed job's url starts with `"https://remoteok.com"`.
- `test_zero_salary_becomes_none(self, remoteok_platform)`: Test `_parse()` directly with an entry where `salary_min=0` and `salary_max=0`. Assert `job.salary_min is None` and `job.salary_max is None`.
- `test_missing_position_returns_none(self, remoteok_platform)`: Test `_parse()` directly with an entry where `position=""`. Assert `_parse()` returns `None`.
- `test_missing_company_returns_none(self, remoteok_platform)`: Test `_parse()` directly with an entry where `company=""`. Assert returns `None`.
- `test_missing_url_returns_none(self, remoteok_platform)`: Test `_parse()` directly with an entry where `url=""`. Assert returns `None`.

**class TestRemoteOKErrorHandling (API-02):**

- `test_http_error_returns_empty_list(self, remoteok_platform)`: Use `respx.mock` context manager. Mock `https://remoteok.com/api` to return 500. Call `platform.search(...)`. Assert result is `[]` (not an exception).
- `test_connection_error_returns_empty_list(self, remoteok_platform)`: Use `respx.mock`. Mock to raise `httpx.ConnectError`. Call `platform.search(...)`. Assert result is `[]`.
- `test_malformed_json_returns_empty_list(self, remoteok_platform)`: Use `respx.mock`. Mock to return 200 with non-JSON body (`"not json"`). Call `platform.search(...)`. Assert result is `[]`.
- `test_empty_response_returns_empty_list(self, remoteok_platform)`: Use `respx.mock`. Mock to return 200 with `json=[]` (empty array). Call `platform.search(...)`. Assert result is `[]`.
- `test_metadata_only_response_returns_empty_list(self, remoteok_platform)`: Use `respx.mock`. Mock to return 200 with `json=[{"legal": "..."}]` (only metadata, no jobs). Call `platform.search(...)`. Assert result is `[]`.

**Important implementation notes:**
- The `mock_remoteok_api` fixture uses `respx.mock` context manager and mocks `GET https://remoteok.com/api`. It yields the sample response for verification.
- For error handling tests (API-02), do NOT use `mock_remoteok_api` -- instead create local `respx.mock` context managers with specific error conditions.
- `RemoteOKPlatform._parse()` is a private method but can be called directly for unit-level parsing tests. Access via `platform._parse(entry_dict)`.
- The `remoteok_platform` fixture loads test config AND calls `init()` (creates httpx client).
- `SearchQuery` requires `query` and `platform` fields at minimum.
- The test config has `tech_keywords: ["python", "kubernetes", "terraform"]` and `min_salary: 100000`. Both mock jobs have salary above 100k, so both should pass the filter.
  </action>
  <verify>
Run: `uv run pytest tests/platforms/test_remoteok.py -v --tb=short -m integration` -- all tests pass.
Run: `uv run pytest tests/platforms/test_remoteok.py -v --tb=short 2>&1 | grep -c "PASSED"` -- expect 22 passed tests.
  </verify>
  <done>TestRemoteOKParsing has 17 tests covering: search returns jobs, all Job fields verified (title, company, platform, location, salary, url, apply_url, tags, posted_date, description), metadata skipping, relative URL prefix, zero salary to None, missing required fields return None. TestRemoteOKErrorHandling has 5 tests covering: HTTP 500, connection error, malformed JSON, empty response, metadata-only response -- all return empty list. All marked @pytest.mark.integration.</done>
</task>

<task type="auto">
  <name>Task 2: Create tests/platforms/test_registry.py with discovery and protocol compliance tests (API-03, API-04)</name>
  <files>tests/platforms/test_registry.py</files>
  <action>
Create `tests/platforms/test_registry.py` with integration tests for platform registry auto-discovery and protocol compliance. Mark all test classes with `@pytest.mark.integration`.

**Critical detail:** Importing `platforms` (the package) triggers `_auto_discover()` which imports all platform modules and runs `@register_platform` decorators. This is the correct import for testing discovery. The tests should NOT call `init()` on browser platforms (IndeedPlatform, DicePlatform) since that requires a Playwright `BrowserContext`.

```python
import pytest
import platforms  # Triggers _auto_discover()
from platforms.registry import get_all_platforms, get_platform, get_platforms_by_type, PlatformInfo
from platforms.protocols import APIPlatform, BrowserPlatform
```

**class TestPlatformRegistry (API-03):**

- `test_registry_contains_indeed(self)`: `platforms = get_all_platforms()`. Assert `"indeed" in platforms`.
- `test_registry_contains_dice(self)`: Assert `"dice" in platforms`.
- `test_registry_contains_remoteok(self)`: Assert `"remoteok" in platforms`.
- `test_registry_has_exactly_three_platforms(self)`: Assert `len(get_all_platforms()) == 3`.
- `test_indeed_metadata(self)`: `info = get_platform("indeed")`. Assert `isinstance(info, PlatformInfo)`. Assert `info.name == "Indeed"`. Assert `info.platform_type == "browser"`.
- `test_dice_metadata(self)`: `info = get_platform("dice")`. Assert `info.name == "Dice"`. Assert `info.platform_type == "browser"`.
- `test_remoteok_metadata(self)`: `info = get_platform("remoteok")`. Assert `info.name == "RemoteOK"`. Assert `info.platform_type == "api"`.
- `test_get_platform_nonexistent_raises_keyerror(self)`: `pytest.raises(KeyError, match="not registered")` when calling `get_platform("glassdoor")`.
- `test_get_platforms_by_type_browser(self)`: `browser = get_platforms_by_type("browser")`. Assert `"indeed" in browser`. Assert `"dice" in browser`. Assert `"remoteok" not in browser`.
- `test_get_platforms_by_type_api(self)`: `api = get_platforms_by_type("api")`. Assert `"remoteok" in api`. Assert `"indeed" not in api`. Assert `"dice" not in api`.
- `test_platform_info_has_cls(self)`: For each platform in `get_all_platforms().values()`, assert `info.cls is not None` and `callable(info.cls)` (it's a class, not an instance).

**class TestProtocolCompliance (API-04):**

- `test_remoteok_is_api_platform(self)`: `info = get_platform("remoteok")`. Create instance: `instance = info.cls()`. Assert `isinstance(instance, APIPlatform)`.
- `test_indeed_is_browser_platform(self)`: `info = get_platform("indeed")`. Create instance: `instance = info.cls()`. Assert `isinstance(instance, BrowserPlatform)`.
- `test_dice_is_browser_platform(self)`: `info = get_platform("dice")`. Create instance: `instance = info.cls()`. Assert `isinstance(instance, BrowserPlatform)`.
- `test_remoteok_is_not_browser_platform(self)`: `instance = get_platform("remoteok").cls()`. Assert `not isinstance(instance, BrowserPlatform)`.
- `test_all_platforms_have_platform_name(self)`: For each platform in registry, create instance. Assert `hasattr(instance, "platform_name")`. Assert `instance.platform_name` is a non-empty string.
- `test_all_platforms_have_search_method(self)`: For each platform, assert `hasattr(instance, "search")` and `callable(instance.search)`.
- `test_all_platforms_have_apply_method(self)`: For each platform, assert `hasattr(instance, "apply")` and `callable(instance.apply)`.
- `test_all_platforms_have_get_job_details_method(self)`: For each platform, assert `hasattr(instance, "get_job_details")` and `callable(instance.get_job_details)`.
- `test_all_platforms_are_context_managers(self)`: For each platform, assert `hasattr(instance, "__enter__")` and `hasattr(instance, "__exit__")`.

**Important implementation notes:**
- `isinstance()` with `runtime_checkable` Protocol works for structural subtyping -- it checks that the instance has all required methods. Creating an instance (e.g., `IndeedPlatform()`) is safe -- the constructor just sets `self.page = None` etc. It does NOT require a BrowserContext.
- Do NOT call `instance.init()` on browser platforms -- that expects a `BrowserContext` argument.
- Do NOT call `instance.init()` on RemoteOK either in the registry tests -- that creates a real httpx client. Only test metadata and protocol compliance via `isinstance()` and `hasattr()`.
- The `import platforms` at the top triggers auto-discovery. If this fails (e.g., a platform module has a bug), the import error will be the test failure.
  </action>
  <verify>
Run: `uv run pytest tests/platforms/test_registry.py -v --tb=short -m integration` -- all tests pass.
Run: `uv run pytest tests/platforms/test_registry.py -v --tb=short 2>&1 | grep -c "PASSED"` -- expect 20 passed tests.
Run: `uv run pytest tests/platforms/ -v --tb=short` -- all platform tests pass (22 remoteok + 20 registry = 42).
  </verify>
  <done>TestPlatformRegistry has 11 tests covering: all 3 platforms discovered, exactly 3 registered, correct metadata per platform (name, type), KeyError for nonexistent, type-based filtering, cls is callable. TestProtocolCompliance has 9 tests covering: isinstance checks against APIPlatform and BrowserPlatform, negative isinstance check, platform_name attribute, search/apply/get_job_details methods, context manager support. All marked @pytest.mark.integration.</done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/platforms/test_remoteok.py -v --tb=short` -- all 22 tests pass
2. `uv run pytest tests/platforms/test_registry.py -v --tb=short` -- all 20 tests pass
3. `uv run pytest tests/platforms/ -v --tb=short` -- all 42 platform tests pass
4. `uv run pytest tests/ -v --tb=short -q` -- all existing tests still pass (no regressions)
</verification>

<success_criteria>
- tests/platforms/test_remoteok.py has TestRemoteOKParsing (17 tests) verifying all Job field mappings, metadata skipping, URL prefix, zero salary handling, missing field returns None
- tests/platforms/test_remoteok.py has TestRemoteOKErrorHandling (5 tests) verifying graceful empty-list return on HTTP error, connection error, malformed JSON, empty response, metadata-only response
- tests/platforms/test_registry.py has TestPlatformRegistry (11 tests) verifying discovery of all 3 platforms with correct metadata, KeyError handling, type-based filtering
- tests/platforms/test_registry.py has TestProtocolCompliance (9 tests) verifying isinstance checks against both Protocol types, method existence, context manager support
- All tests pass with `uv run pytest tests/platforms/ -v`
- All tests marked with `@pytest.mark.integration`
</success_criteria>

<output>
After completion, create `.planning/phases/12-web-api-integration-tests/12-03-SUMMARY.md`
</output>
