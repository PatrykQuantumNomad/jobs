---
phase: 02-platform-architecture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - platforms/protocols.py
  - platforms/registry.py
  - platforms/mixins.py
autonomous: true

must_haves:
  truths:
    - "BrowserPlatform and APIPlatform Protocol classes exist with all required method signatures"
    - "@register_platform decorator validates protocol compliance at import time -- missing methods cause immediate TypeError"
    - "BrowserPlatformMixin provides human_delay, screenshot, wait_for_human, element_exists utilities"
    - "Registry stores PlatformInfo dataclass with key, name, platform_type, cls, and capabilities"
  artifacts:
    - path: "platforms/protocols.py"
      provides: "BrowserPlatform and APIPlatform Protocol definitions"
      contains: "class BrowserPlatform"
    - path: "platforms/protocols.py"
      provides: "APIPlatform Protocol definition"
      contains: "class APIPlatform"
    - path: "platforms/registry.py"
      provides: "@register_platform decorator, _REGISTRY dict, get_platform(), get_all_platforms()"
      contains: "def register_platform"
    - path: "platforms/mixins.py"
      provides: "BrowserPlatformMixin with shared browser utility methods"
      contains: "class BrowserPlatformMixin"
  key_links:
    - from: "platforms/registry.py"
      to: "platforms/protocols.py"
      via: "import for validation"
      pattern: "from platforms\\.protocols import"
    - from: "platforms/registry.py"
      to: "inspect module"
      via: "signature validation"
      pattern: "inspect\\.signature"
---

<objective>
Create the Protocol definitions, decorator-based registry, and shared utility mixin that form the foundation of the pluggable platform architecture.

Purpose: These three files are the infrastructure that all platform adapters and the orchestrator will depend on. They must exist and be importable before any migration work begins.
Output: Three new files -- `protocols.py`, `registry.py`, `mixins.py` -- in the `platforms/` directory.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-platform-architecture/02-RESEARCH.md
@.planning/phases/02-platform-architecture/02-CONTEXT.md
@platforms/base.py
@models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Protocol definitions and registry with validation</name>
  <files>platforms/protocols.py, platforms/registry.py</files>
  <action>
Create `platforms/protocols.py` with two `@runtime_checkable` Protocol classes:

**BrowserPlatform Protocol:**
- `platform_name: str` (class attribute)
- `def init(self, context: BrowserContext) -> None` -- receives Playwright BrowserContext from orchestrator
- `def login(self) -> bool` -- authenticate, return True if fresh login
- `def is_logged_in(self) -> bool`
- `def search(self, query: SearchQuery) -> list[Job]` -- search and return Job models (NOT raw cards -- per research recommendation, orchestrator should not care about raw card formats)
- `def get_job_details(self, job: Job) -> Job` -- enrich with full description
- `def apply(self, job: Job, resume_path: Path | None = None) -> bool` -- submit application with human confirmation
- `def __enter__(self) -> BrowserPlatform`
- `def __exit__(self, exc_type, exc_val, exc_tb) -> None`

**APIPlatform Protocol:**
- `platform_name: str` (class attribute)
- `def init(self) -> None` -- initialize HTTP client (no BrowserContext needed)
- `def search(self, query: SearchQuery) -> list[Job]`
- `def get_job_details(self, job: Job) -> Job`
- `def apply(self, job: Job, resume_path: Path | None = None) -> bool`
- `def __enter__(self) -> APIPlatform`
- `def __exit__(self, exc_type, exc_val, exc_tb) -> None`

Note: APIPlatform does NOT have `login()` or `is_logged_in()` -- API platforms don't authenticate via browser.

Use `from __future__ import annotations` at the top. Import types under `TYPE_CHECKING` where possible to avoid circular imports. Import `Job` and `SearchQuery` from `models` directly (not under TYPE_CHECKING -- they're needed at runtime for Protocol definition).

Create `platforms/registry.py` with:

1. `PlatformInfo` dataclass: `key` (str), `name` (str), `platform_type` (str: "browser"|"api"), `cls` (type), `capabilities` (list[str], default_factory=list)

2. Module-level `_REGISTRY: dict[str, PlatformInfo] = {}`

3. `register_platform(key, *, name=None, platform_type="browser", capabilities=None)` decorator that:
   - Imports protocols lazily inside the decorator function (avoids circular imports -- decorator is called at platform module import time)
   - Selects BrowserPlatform or APIPlatform based on `platform_type`
   - Calls `_validate_against_protocol(cls, protocol)` for fail-fast validation
   - Checks for duplicate key registration (raise ValueError)
   - Stores PlatformInfo in _REGISTRY
   - Returns cls unchanged

4. `_validate_against_protocol(cls, protocol)` function that:
   - Collects protocol-defined methods from `vars(protocol)` (skip private except `__enter__`, `__exit__`)
   - Also checks for `platform_name` attribute via `hasattr(cls, 'platform_name')`
   - For each required method, checks `hasattr(cls, method_name)` -- raises TypeError listing missing methods
   - Uses `inspect.signature()` to compare parameter counts -- implementation must not require MORE parameters than protocol defines (but may accept fewer, i.e., have defaults)
   - Catches ValueError/TypeError from inspect gracefully (some builtins not introspectable)

5. `get_platform(key: str) -> PlatformInfo` -- raises KeyError with helpful message listing available platforms
6. `get_all_platforms() -> dict[str, PlatformInfo]` -- returns copy of registry
7. `get_platforms_by_type(platform_type: str) -> dict[str, PlatformInfo]` -- filter by type

Use `from __future__ import annotations` in both files. Keep the import chain linear: models -> protocols -> registry (registry imports from protocols, NOT vice versa).
  </action>
  <verify>
Run: `python -c "from platforms.protocols import BrowserPlatform, APIPlatform; print('Protocols OK')"` -- should print "Protocols OK" without errors.

Run: `python -c "from platforms.registry import register_platform, get_platform, get_all_platforms; print('Registry OK')"` -- should print "Registry OK".

Verify fail-fast validation works:
```python
python -c "
from platforms.registry import register_platform
# Should raise TypeError for missing methods
try:
    @register_platform('test_bad', platform_type='browser')
    class BadPlatform:
        platform_name = 'test'
    print('ERROR: should have raised')
except TypeError as e:
    print(f'Validation works: {e}')
"
```
  </verify>
  <done>Both Protocol classes importable with correct method signatures. Registry decorator validates compliance and raises TypeError for incomplete implementations. PlatformInfo dataclass stores metadata. No circular import issues.</done>
</task>

<task type="auto">
  <name>Task 2: Create BrowserPlatformMixin with shared utilities</name>
  <files>platforms/mixins.py</files>
  <action>
Create `platforms/mixins.py` containing `BrowserPlatformMixin` class that provides the four utility methods currently in `BasePlatform`:

1. `human_delay(self, delay_type: str = "nav") -> None` -- randomized delay using `get_settings().timing` (nav: nav_delay_min/max, form: form_delay_min/max). Identical logic to current `BasePlatform.human_delay`.

2. `screenshot(self, name: str) -> Path` -- save full-page screenshot to `DEBUG_SCREENSHOTS_DIR`. Uses `self.platform_name` for filename prefix and `self.page` for the screenshot call. Identical logic to current `BasePlatform.screenshot`.

3. `wait_for_human(self, message: str) -> str` -- block for human input at checkpoint. Uses `self.platform_name` in the header. Identical logic to current `BasePlatform.wait_for_human`.

4. `element_exists(self, selector: str, timeout: int = 5000) -> bool` -- non-throwing element check using `self.page.wait_for_selector`. Identical logic to current `BasePlatform.element_exists`.

The mixin expects `self.page` (Playwright Page) and `self.platform_name` (str) to exist on the consuming class. Do NOT set these in the mixin -- they're set by the platform's `__init__` or `init()`.

Import `DEBUG_SCREENSHOTS_DIR` from `config` as a module-level constant (per Phase 1 decision -- it's a static path). Import `get_settings` from `config` for timing access.

Use `from __future__ import annotations`.
  </action>
  <verify>
Run: `python -c "from platforms.mixins import BrowserPlatformMixin; print('Mixin OK')"` -- should print "Mixin OK".

Verify the mixin has all four methods:
```python
python -c "
from platforms.mixins import BrowserPlatformMixin
methods = ['human_delay', 'screenshot', 'wait_for_human', 'element_exists']
for m in methods:
    assert hasattr(BrowserPlatformMixin, m), f'Missing: {m}'
print('All 4 utility methods present')
"
```
  </verify>
  <done>BrowserPlatformMixin class exists with human_delay, screenshot, wait_for_human, and element_exists methods. Logic is identical to current BasePlatform utilities. Mixin expects self.page and self.platform_name from the consuming class.</done>
</task>

</tasks>

<verification>
All three infrastructure files exist and are importable without errors:
```bash
python -c "
from platforms.protocols import BrowserPlatform, APIPlatform
from platforms.registry import register_platform, get_platform, get_all_platforms, get_platforms_by_type
from platforms.mixins import BrowserPlatformMixin
print('All infrastructure modules OK')
"
```

Registry validation catches missing methods (fail-fast):
```bash
python -c "
from platforms.registry import register_platform
try:
    @register_platform('test_incomplete', platform_type='api')
    class Incomplete:
        platform_name = 'test'
    print('FAIL: should have raised TypeError')
except TypeError as e:
    print(f'PASS: {e}')
"
```

No circular imports between protocols.py, registry.py, and mixins.py.
</verification>

<success_criteria>
- protocols.py defines BrowserPlatform and APIPlatform as @runtime_checkable Protocol classes
- registry.py provides @register_platform decorator with fail-fast protocol validation via inspect
- mixins.py provides BrowserPlatformMixin with all four BasePlatform utility methods
- Import chain is linear: models -> protocols -> registry (no cycles)
- All files importable without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-platform-architecture/02-01-SUMMARY.md`
</output>
