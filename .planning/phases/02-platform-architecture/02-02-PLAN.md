---
phase: 02-platform-architecture
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - platforms/indeed.py
  - platforms/dice.py
  - platforms/remoteok.py
  - platforms/__init__.py
  - platforms/base.py
  - orchestrator.py
autonomous: true

must_haves:
  truths:
    - "IndeedPlatform, DicePlatform, and RemoteOKPlatform are registered via @register_platform decorator"
    - "All three adapters work identically after migration -- same search results, same apply flow"
    - "Orchestrator iterates over registered platforms from config without any if/elif branching for platform names"
    - "RemoteOK uses sync httpx.Client instead of async httpx.AsyncClient"
    - "BasePlatform ABC no longer exists -- platforms/base.py is deleted"
    - "Adding a new platform file to platforms/ with @register_platform is sufficient to register it"
    - "platforms/__init__.py auto-discovers platform modules via pkgutil"
  artifacts:
    - path: "platforms/indeed.py"
      provides: "Indeed platform registered via decorator, using BrowserPlatformMixin"
      contains: "@register_platform"
    - path: "platforms/dice.py"
      provides: "Dice platform registered via decorator, using BrowserPlatformMixin"
      contains: "@register_platform"
    - path: "platforms/remoteok.py"
      provides: "RemoteOK platform registered via decorator, sync httpx.Client"
      contains: "@register_platform"
    - path: "platforms/__init__.py"
      provides: "Auto-discovery via pkgutil, exposes registry functions"
      contains: "_auto_discover"
    - path: "orchestrator.py"
      provides: "Generic platform iteration via registry -- no if/elif for platform names"
      contains: "get_platform"
  key_links:
    - from: "platforms/indeed.py"
      to: "platforms/registry.py"
      via: "@register_platform decorator import"
      pattern: "from platforms\\.registry import register_platform"
    - from: "platforms/indeed.py"
      to: "platforms/mixins.py"
      via: "BrowserPlatformMixin inheritance"
      pattern: "class IndeedPlatform\\(BrowserPlatformMixin\\)"
    - from: "platforms/dice.py"
      to: "platforms/registry.py"
      via: "@register_platform decorator import"
      pattern: "from platforms\\.registry import register_platform"
    - from: "platforms/remoteok.py"
      to: "platforms/registry.py"
      via: "@register_platform decorator import"
      pattern: "from platforms\\.registry import register_platform"
    - from: "orchestrator.py"
      to: "platforms/registry.py"
      via: "get_platform lookup"
      pattern: "from platforms import get_platform"
    - from: "platforms/__init__.py"
      to: "pkgutil"
      via: "auto-discovery"
      pattern: "pkgutil\\.iter_modules"
---

<objective>
Migrate all three platform adapters to the new Protocol architecture, rewrite the orchestrator to use the registry for generic platform iteration, update __init__.py for auto-discovery, and remove the BasePlatform ABC.

Purpose: This is the "big bang" migration per user decision -- adapters, orchestrator refactor, and ABC removal happen together as one coherent change. After this plan, the platform architecture is fully pluggable.
Output: Updated indeed.py, dice.py, remoteok.py, orchestrator.py, __init__.py. Deleted base.py.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-platform-architecture/02-RESEARCH.md
@.planning/phases/02-platform-architecture/02-CONTEXT.md
@.planning/phases/02-platform-architecture/02-01-SUMMARY.md
@platforms/indeed.py
@platforms/dice.py
@platforms/remoteok.py
@platforms/base.py
@platforms/__init__.py
@platforms/stealth.py
@orchestrator.py
@models.py
@config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate all three platform adapters and update __init__.py</name>
  <files>platforms/indeed.py, platforms/dice.py, platforms/remoteok.py, platforms/__init__.py, platforms/base.py</files>
  <action>
**Migrate IndeedPlatform (platforms/indeed.py):**

1. Remove `from platforms.base import BasePlatform` import.
2. Add `from platforms.mixins import BrowserPlatformMixin` and `from platforms.registry import register_platform`.
3. Add decorator: `@register_platform("indeed", name="Indeed", platform_type="browser", capabilities=["easy_apply"])`
4. Change class to inherit from `BrowserPlatformMixin` instead of `BasePlatform`.
5. Replace constructor:
   - Old: `def __init__(self, context: BrowserContext)` that calls `super().__init__(context)`
   - New: `def __init__(self) -> None` that sets `self.context = None` and `self.page = None`
6. Add `init(self, context: BrowserContext) -> None` method that sets `self.context = context` and `self.page = context.pages[0] if context.pages else context.new_page()`. This replaces what `BasePlatform.__init__` used to do.
7. Add `__enter__` returning `self` and `__exit__` that passes (BrowserContext lifecycle managed by orchestrator).
8. Update `apply` signature: `def apply(self, job: Job, resume_path: Path | None = None) -> bool`. Inside the method, if `resume_path is None`, fall back to `PROJECT_ROOT / get_settings().candidate_resume_path`.
9. All existing method bodies (login, is_logged_in, search, get_job_details, _extract_card, _build_search_url, _is_sponsored, _detect_captcha, _detect_email_verification, _check_challenges) remain UNCHANGED. They already use `self.page` and `self.platform_name` which the mixin and init() provide.
10. Keep all module-level helpers (_parse_salary) unchanged.

**Migrate DicePlatform (platforms/dice.py):**

Same pattern as Indeed:
1. Remove `from platforms.base import BasePlatform`.
2. Add `from platforms.mixins import BrowserPlatformMixin` and `from platforms.registry import register_platform`.
3. Decorator: `@register_platform("dice", name="Dice", platform_type="browser", capabilities=["easy_apply"])`
4. Inherit from `BrowserPlatformMixin`.
5. Constructor: `def __init__(self) -> None` sets `self.context = None`, `self.page = None`.
6. Add `init(self, context: BrowserContext) -> None` method.
7. Add `__enter__`/`__exit__`.
8. Update `apply` signature to `(self, job: Job, resume_path: Path | None = None) -> bool` with fallback.
9. All existing method bodies unchanged.
10. Keep module-level helpers (_parse_card_text, _parse_salary) unchanged.

**Migrate RemoteOKPlatform (platforms/remoteok.py):**

1. Add `from platforms.registry import register_platform`.
2. Decorator: `@register_platform("remoteok", name="RemoteOK", platform_type="api")`
3. **Convert from async to sync** (per research -- eliminates async/sync mismatch):
   - Change `self.client = httpx.AsyncClient(...)` to create nothing in `__init__` (set `self.client = None`).
   - Add `init(self) -> None` that creates `self.client = httpx.Client(headers={"User-Agent": "JobSearchBot/1.0 (pgolabek@gmail.com)"}, timeout=30.0)`.
   - Change `async def search(self, query: SearchQuery)` to `def search(self, query: SearchQuery)`.
   - Replace `await self.client.get(...)` with `self.client.get(...)`.
   - Remove `async def close(self)` -- cleanup moves to `__exit__`.
4. Add `__enter__` returning `self` and `__exit__` that closes `self.client` if not None.
5. Update `apply` signature: `def apply(self, job: Job, resume_path: Path | None = None) -> bool` (ignore resume_path -- external ATS).
6. All filtering/parsing logic (_filter_terms, _matches, _parse) remains UNCHANGED.

**Update platforms/__init__.py:**

Replace the current lazy `__getattr__` implementation with auto-discovery:

```python
"""Platform modules -- auto-discovers and registers all platform implementations."""
from __future__ import annotations

import importlib
import logging
import pkgutil
from pathlib import Path

from platforms.registry import get_all_platforms, get_platform, get_platforms_by_type

logger = logging.getLogger(__name__)

# Modules that are infrastructure, not platform implementations
_INFRASTRUCTURE_MODULES = frozenset({
    "protocols", "registry", "mixins", "stealth", "base",
})


def _auto_discover() -> None:
    """Import all platform modules to trigger @register_platform decorators."""
    pkg_dir = str(Path(__file__).parent)
    for _finder, module_name, _is_pkg in pkgutil.iter_modules([pkg_dir]):
        if module_name in _INFRASTRUCTURE_MODULES or module_name.endswith("_selectors"):
            continue
        try:
            importlib.import_module(f"platforms.{module_name}")
        except Exception:
            logger.exception("Failed to load platform module '%s'", module_name)


_auto_discover()

# Re-export stealth functions for backward compatibility
from platforms.stealth import close_browser, get_browser_context  # noqa: E402

__all__ = [
    "get_platform",
    "get_all_platforms",
    "get_platforms_by_type",
    "get_browser_context",
    "close_browser",
]
```

Note: Keep `get_browser_context` and `close_browser` re-exported -- they're used directly by the orchestrator for browser lifecycle management.

**Delete platforms/base.py:**

Delete the file entirely. The BasePlatform ABC is replaced by protocols + mixin. Per user decision: "Remove BasePlatform ABC immediately once all adapters use protocols -- no dead code, no deprecated shims."
  </action>
  <verify>
Verify all three platforms register successfully on import:
```bash
python -c "
from platforms import get_all_platforms
registered = get_all_platforms()
print(f'Registered platforms: {list(registered.keys())}')
assert 'indeed' in registered, 'Indeed not registered'
assert 'dice' in registered, 'Dice not registered'
assert 'remoteok' in registered, 'RemoteOK not registered'
assert registered['indeed'].platform_type == 'browser'
assert registered['dice'].platform_type == 'browser'
assert registered['remoteok'].platform_type == 'api'
print('All 3 platforms registered with correct types')
"
```

Verify BasePlatform is gone:
```bash
python -c "
import os
assert not os.path.exists('platforms/base.py'), 'base.py still exists'
print('base.py deleted')
"
```

Verify RemoteOK is sync:
```bash
python -c "
import inspect
from platforms.remoteok import RemoteOKPlatform
assert not inspect.iscoroutinefunction(RemoteOKPlatform.search), 'search is still async'
print('RemoteOK.search is sync')
"
```
  </verify>
  <done>All three adapters use @register_platform decorator and pass protocol validation. IndeedPlatform and DicePlatform inherit from BrowserPlatformMixin. RemoteOKPlatform uses sync httpx.Client. __init__.py auto-discovers modules via pkgutil. BasePlatform ABC is deleted.</done>
</task>

<task type="auto">
  <name>Task 2: Refactor orchestrator to use registry-based platform iteration</name>
  <files>orchestrator.py</files>
  <action>
Rewrite the orchestrator to eliminate all if/elif branching on platform names. The orchestrator should use the registry to look up platforms and branch only on platform TYPE (browser vs api), NOT platform identity.

**Phase 1 (login) refactor:**

Replace the current hardcoded `if "indeed" in platforms` / `if "dice" in platforms` / `if "remoteok" in platforms` pattern with:

```python
def phase_1_login(self, platforms: list[str]) -> None:
    print("\n[Phase 1] Platform Login")
    print("-" * 60)

    for name in platforms:
        info = get_platform(name)
        if info.platform_type == "api":
            print(f"  {info.name}: no login required")
            continue
        if not self.settings.validate_platform_credentials(name):
            print(f"  {info.name}: credentials missing, skipping")
            self._failed_logins.add(name)
            continue
        self._login_platform(name, info)
```

**_login_platform refactor:**

Replace the `if name == "indeed"` / `elif name == "dice"` branching:

```python
def _login_platform(self, name: str, info: PlatformInfo) -> None:
    pw, ctx = None, None
    try:
        pw, ctx = get_browser_context(name, headless=self.headless)
        platform = info.cls()
        platform.init(ctx)
        with platform:
            platform.login()
    except Exception as exc:
        print(f"  {info.name}: login failed -- {exc}")
        print(f"  Skipping {info.name} for this run.")
        self._failed_logins.add(name)
    finally:
        if pw and ctx:
            close_browser(pw, ctx)
```

**Phase 2 (search) refactor:**

Replace `_search_browser_platform` and `_search_remoteok` with a single generic method:

```python
def phase_2_search(self, platforms: list[str]) -> None:
    print("\n[Phase 2] Job Search")
    print("-" * 60)

    for name in platforms:
        if name in self._failed_logins:
            info = get_platform(name)
            print(f"  Skipping {info.name} (login failed)")
            continue
        info = get_platform(name)
        if info.platform_type == "browser" and not self.settings.validate_platform_credentials(name):
            continue
        jobs = self._search_platform(name, info)
        self._save_raw(name, jobs)
```

```python
def _search_platform(self, name: str, info: PlatformInfo) -> list[Job]:
    queries = self.settings.get_search_queries(platform=name)
    all_jobs: list[Job] = []

    platform = info.cls()

    if info.platform_type == "browser":
        pw, ctx = get_browser_context(name, headless=self.headless)
        platform.init(ctx)
    else:
        platform.init()
        pw, ctx = None, None

    with platform:
        for q in queries:
            try:
                found = platform.search(q)
                if info.platform_type == "browser":
                    for job in found:
                        job = platform.get_job_details(job)
                        all_jobs.append(job)
                else:
                    all_jobs.extend(found)
            except Exception as exc:
                print(f"  {info.name}: error on '{q.query}' -- {exc}")
                continue

    if info.platform_type == "browser" and pw and ctx:
        close_browser(pw, ctx)

    return all_jobs
```

**Phase 4 (apply) refactor:**

Replace `_apply_to` method's if/elif branching:

```python
def _apply_to(self, job: Job) -> None:
    print(f"\n  Applying: {job.company} -- {job.title}")

    info = get_platform(job.platform)

    if info.platform_type == "api":
        platform = info.cls()
        platform.init()
        with platform:
            platform.apply(job)
        return

    # Browser platform -- visible mode for human oversight
    resume = PROJECT_ROOT / self.settings.candidate_resume_path
    pw, ctx = get_browser_context(job.platform, headless=False)

    try:
        platform = info.cls()
        platform.init(ctx)
        with platform:
            success = platform.apply(job, resume)

        if success:
            job.status = JobStatus.APPLIED
            job.applied_date = datetime.now().isoformat()
            print(f"  Application submitted to {job.company}")
        else:
            print(f"  Application not submitted for {job.company}")
    except Exception as exc:
        print(f"  Application error: {exc}")
    finally:
        close_browser(pw, ctx)

    self._write_tracker(self.discovered_jobs)
```

**Phase 0 (setup) refactor:**

Replace the hardcoded `for p in ("indeed", "dice", "remoteok")` credential check with iteration over registered platforms:

```python
print("  Credentials:")
for name in get_all_platforms():
    ok = self.settings.validate_platform_credentials(name)
    print(f"    {name:10s} {'OK' if ok else 'MISSING'}")
```

**_load_raw_results refactor:**

Replace `for name in ("indeed", "dice", "remoteok")` with `for name in get_all_platforms()`.

**Import changes at the top of orchestrator.py:**

- Remove `import asyncio` (no longer needed -- RemoteOK is sync)
- Add `from platforms import get_platform, get_all_platforms, get_browser_context, close_browser`
- Add `from platforms.registry import PlatformInfo`
- Remove the inline imports of `IndeedPlatform`, `DicePlatform`, `RemoteOKPlatform`, `get_browser_context`, `close_browser` scattered throughout methods

**CLI argument update:**

The `--platforms` `choices` should not be hardcoded. Change:
```python
# Old:
choices=["indeed", "dice", "remoteok"],
# New -- remove choices constraint entirely, let registry validate:
# Keep it simple -- remove choices, the registry's get_platform() will raise
# KeyError with a helpful message if an invalid platform is passed
```
Remove the `choices` parameter from `--platforms` argparse argument. The registry's `get_platform()` already raises a KeyError with available platforms listed. Add a startup validation in `run()` that checks all requested platforms exist in the registry:

```python
def run(self, platforms: list[str] | None = None) -> None:
    if platforms is None:
        platforms = self.settings.enabled_platforms()

    # Validate all requested platforms are registered
    for name in platforms:
        get_platform(name)  # Raises KeyError if not registered

    # ... rest of pipeline
```

**Key principle:** The orchestrator branches on platform TYPE (browser vs api) but NEVER on platform NAME. The type distinction is structural (browsers need login/context, APIs don't) -- adding a new browser platform or a new API platform requires ZERO orchestrator changes.
  </action>
  <verify>
Verify no if/elif branching on platform names in orchestrator:
```bash
python -c "
with open('orchestrator.py') as f:
    content = f.read()
# Check for platform name branching (should be gone)
for name in ['indeed', 'dice', 'remoteok']:
    # Allow platform name in strings/comments, but not in if/elif conditions
    import re
    # Look for if/elif statements that branch on specific platform names
    pattern = rf'if\s+.*[\"\\x27]{name}[\"\\x27]|elif\s+.*[\"\\x27]{name}[\"\\x27]'
    matches = re.findall(pattern, content)
    if matches:
        print(f'WARNING: Found platform-name branching for {name}: {matches}')
    else:
        print(f'OK: No branching on \"{name}\"')
print('Orchestrator refactor verified')
"
```

Verify asyncio import is gone:
```bash
python -c "
with open('orchestrator.py') as f:
    content = f.read()
assert 'import asyncio' not in content, 'asyncio still imported'
assert 'asyncio.run' not in content, 'asyncio.run still used'
print('No asyncio usage')
"
```

Verify orchestrator imports from registry:
```bash
python -c "
with open('orchestrator.py') as f:
    content = f.read()
assert 'get_platform' in content, 'get_platform not imported'
assert 'get_all_platforms' in content, 'get_all_platforms not imported'
print('Registry imports present')
"
```

Verify the full import chain works (orchestrator -> platforms -> registry -> protocols):
```bash
python -c "
from orchestrator import Orchestrator
print('Orchestrator imports successfully')
"
```
  </verify>
  <done>Orchestrator uses get_platform() and get_all_platforms() from registry. All if/elif branching on platform names is eliminated. Platform type (browser/api) is the only structural distinction. asyncio is removed. Adding a new platform requires zero orchestrator changes.</done>
</task>

</tasks>

<verification>
Full architecture verification:

1. All platforms registered via auto-discovery:
```bash
python -c "
from platforms import get_all_platforms, get_platforms_by_type
all_p = get_all_platforms()
print(f'Total registered: {len(all_p)}')
print(f'Browser platforms: {list(get_platforms_by_type(\"browser\").keys())}')
print(f'API platforms: {list(get_platforms_by_type(\"api\").keys())}')
assert len(all_p) == 3
"
```

2. No BasePlatform references remain:
```bash
grep -r "BasePlatform" platforms/ orchestrator.py --include="*.py" || echo "No BasePlatform references found"
```

3. No if/elif on platform names in orchestrator:
```bash
grep -n "indeed\|dice\|remoteok" orchestrator.py | grep -v "#\|print\|import" || echo "Clean"
```

4. Config --validate still works:
```bash
python orchestrator.py --validate
```

5. Orchestrator class instantiates without error:
```bash
python -c "from orchestrator import Orchestrator; print('OK')"
```
</verification>

<success_criteria>
- IndeedPlatform uses @register_platform("indeed", ...) + BrowserPlatformMixin, no BasePlatform
- DicePlatform uses @register_platform("dice", ...) + BrowserPlatformMixin, no BasePlatform
- RemoteOKPlatform uses @register_platform("remoteok", ...) + sync httpx.Client, no async
- platforms/__init__.py auto-discovers modules via pkgutil.iter_modules
- platforms/base.py is deleted
- Orchestrator branches on platform_type (browser/api), NEVER on platform name
- No asyncio in orchestrator
- `python orchestrator.py --validate` works
- All three platforms discoverable via get_all_platforms()
</success_criteria>

<output>
After completion, create `.planning/phases/02-platform-architecture/02-02-SUMMARY.md`
</output>
