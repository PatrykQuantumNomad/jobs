---
phase: 03-discovery-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - salary.py
  - dedup.py
  - scorer.py
  - models.py
  - pyproject.toml
autonomous: true

must_haves:
  truths:
    - "parse_salary handles all known formats: '$150,000 - $200,000', 'USD 224,400.00 - 283,800.00 per year', '$85/hr', '$175000', '$150K - $200K', '150000-180000 CAD', raw ints from RemoteOK"
    - "Fuzzy dedup merges 'Google' and 'Google LLC' but NOT 'Google' and 'Alphabet'"
    - "score_job returns both an int score and a ScoreBreakdown with per-factor points"
    - "All new Job model fields (company_aliases, salary_display, salary_currency) serialize correctly with model_dump(mode='json')"
  artifacts:
    - path: "salary.py"
      provides: "Unified salary parser replacing 3 platform-specific _parse_salary functions"
      exports: ["parse_salary", "parse_salary_ints", "NormalizedSalary"]
    - path: "dedup.py"
      provides: "Two-pass fuzzy deduplication with merge trail"
      exports: ["fuzzy_deduplicate"]
    - path: "scorer.py"
      provides: "Score breakdown alongside int score"
      exports: ["ScoreBreakdown", "JobScorer"]
    - path: "models.py"
      provides: "Updated Job model with new fields"
      contains: "company_aliases"
  key_links:
    - from: "salary.py"
      to: "models.py"
      via: "NormalizedSalary fields map to Job.salary_min, salary_max, salary_display, salary_currency"
      pattern: "salary_display|salary_currency"
    - from: "dedup.py"
      to: "models.py"
      via: "Sets Job.company_aliases on merge"
      pattern: "company_aliases"
    - from: "scorer.py"
      to: "models.py"
      via: "ScoreBreakdown stored alongside Job.score"
      pattern: "ScoreBreakdown"
---

<objective>
Create the three new data processing modules (salary parser, fuzzy deduplicator, score breakdown) and update the Job model with new fields.

Purpose: These modules are the foundation for all Phase 3 improvements. They must work independently before being wired into the orchestrator and database.
Output: Three working modules (`salary.py`, `dedup.py`, updated `scorer.py`) and an updated `models.py` with new fields.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-discovery-engine/03-RESEARCH.md
@.planning/phases/03-discovery-engine/03-CONTEXT.md

@models.py
@scorer.py
@pyproject.toml
@platforms/indeed.py
@platforms/dice.py
@platforms/remoteok.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create salary.py and dedup.py modules, update models and dependencies</name>
  <files>salary.py, dedup.py, models.py, pyproject.toml</files>
  <action>
**salary.py** -- Create a unified salary parser replacing the three platform-specific `_parse_salary()` functions. Follow the research pattern exactly:

1. `NormalizedSalary` dataclass with fields: `min_annual: int | None`, `max_annual: int | None`, `currency: str`, `raw: str`, `display: str`
2. `parse_salary(text: str | None, default_currency: str = "USD") -> NormalizedSalary` handles:
   - "$150,000 - $200,000" (Indeed range)
   - "$85/hr" or "$85 an hour" (Indeed hourly -- multiply by 2080)
   - "USD 224,400.00 - 283,800.00 per year" (Dice verbose)
   - "$175000" (Dice short)
   - "$150K - $200K" (K notation)
   - "150000-180000 CAD" (currency suffix)
   - Monthly rates (multiply by 12)
   - None/empty -> NormalizedSalary with all None
3. `parse_salary_ints(min_val: int | None, max_val: int | None, currency: str = "USD") -> NormalizedSalary` for RemoteOK which provides salary as integers. Handle RemoteOK quirk: sometimes salary_max = 0 when salary_min > 0.
4. `_format_display(min_val, max_val, currency)` -> compact format "$150K-$180K USD/yr" per user decision. Currency symbols: USD="$", CAD="C$", EUR="EUR", GBP="GBP".
5. Currency detection via regex patterns for USD, CAD, EUR, GBP.

Important: Do NOT convert between currencies. User decision: "Show original currency -- no conversion between USD/CAD/EUR."

**dedup.py** -- Create two-pass fuzzy deduplication engine:

1. Add `rapidfuzz>=3.14` to pyproject.toml dependencies
2. `FUZZY_COMPANY_THRESHOLD = 90` (conservative per user decision)
3. `fuzzy_deduplicate(jobs: list[Job]) -> list[Job]`:
   - Pass 1: exact `dedup_key()` match (existing logic, fast path for ~90% of dupes). Prefer job with more data (longer description, has salary).
   - Pass 2: group remaining by normalized title. Within each group, fuzzy-match company names using `fuzz.token_sort_ratio` on suffix-stripped names.
   - When merging, keep most recent posting (`posted_date`). Record aliases in `job.company_aliases`.
4. `_normalize_company(name: str) -> str`: strip common suffixes (" inc.", " inc", " llc", " ltd", " ltd.", " corp", " corp.", " co.", " company", " incorporated"), lowercase, strip whitespace and trailing commas.
5. Only compare within same-title groups to avoid N-squared. With 500 jobs and ~50 unique titles, this keeps comparisons at ~10 per group.

**models.py** -- Add three new fields to the Job model:
- `company_aliases: list[str] = Field(default_factory=list)` -- merge trail from fuzzy dedup
- `salary_display: str = ""` -- formatted "$150K-$180K USD/yr"
- `salary_currency: str = "USD"` -- original currency code

**pyproject.toml** -- Add `rapidfuzz>=3.14` to the dependencies list.
  </action>
  <verify>
Run: `python -c "from salary import parse_salary, parse_salary_ints, NormalizedSalary; s = parse_salary('$150,000 - $200,000'); assert s.min_annual == 150000; assert s.max_annual == 200000; assert s.currency == 'USD'; assert 'K' in s.display; s2 = parse_salary('$85/hr'); assert s2.min_annual == 85 * 2080; s3 = parse_salary('USD 224,400.00 - 283,800.00 per year'); assert s3.min_annual == 224400; s4 = parse_salary_ints(150000, 180000); assert s4.display != ''; s5 = parse_salary(None); assert s5.min_annual is None; print('salary OK')"`

Run: `python -c "from dedup import fuzzy_deduplicate; from models import Job; jobs = [Job(platform='indeed', title='Staff Engineer', company='Google', url='http://a'), Job(platform='dice', title='Staff Engineer', company='Google LLC', url='http://b')]; result = fuzzy_deduplicate(jobs); assert len(result) == 1; assert len(result[0].company_aliases) >= 1; print('dedup OK')"`

Run: `python -c "from models import Job; j = Job(platform='indeed', title='Test', company='Co', url='http://x', company_aliases=['Co Inc'], salary_display='\$150K USD/yr', salary_currency='CAD'); d = j.model_dump(mode='json'); assert 'company_aliases' in d; print('models OK')"`

Run: `python -c "
from salary import parse_salary, NormalizedSalary
from models import Job
# Verify NormalizedSalary fields map correctly to Job model fields
sal = parse_salary('\$150,000 - \$200,000')
j = Job(platform='indeed', title='Eng', company='Co', url='http://x')
j.salary_min = sal.min_annual
j.salary_max = sal.max_annual
j.salary_display = sal.display
j.salary_currency = sal.currency
assert j.salary_min == 150000, f'salary_min={j.salary_min}'
assert j.salary_max == 200000, f'salary_max={j.salary_max}'
assert j.salary_display != '', f'salary_display empty'
assert j.salary_currency == 'USD', f'salary_currency={j.salary_currency}'
d = j.model_dump(mode='json')
assert d['salary_min'] == 150000
assert d['salary_max'] == 200000
assert d['salary_display'] != ''
assert d['salary_currency'] == 'USD'
print(f'Field mapping OK: min={j.salary_min}, max={j.salary_max}, display={j.salary_display}, currency={j.salary_currency}')
"`
  </verify>
  <done>salary.py handles all 6+ salary formats correctly. dedup.py merges company variants with threshold 90. models.py has new fields that serialize properly. rapidfuzz added to pyproject.toml. NormalizedSalary fields map correctly to Job model fields (salary_min, salary_max, salary_display, salary_currency).</done>
</task>

<task type="auto">
  <name>Task 2: Refactor scorer.py to return ScoreBreakdown alongside int score</name>
  <files>scorer.py</files>
  <action>
Refactor `scorer.py` to produce a `ScoreBreakdown` dataclass alongside the integer score:

1. Add `ScoreBreakdown` dataclass (using stdlib `dataclasses`, not Pydantic -- it's internal, never serialized via Pydantic):
   - `title_points: int = 0` (0-2)
   - `tech_points: int = 0` (0-2)
   - `tech_matched: list[str] = field(default_factory=list)` -- actual matched keywords
   - `remote_points: int = 0` (0-1)
   - `salary_points: int = 0` (0-1)
   - `total: int = 0` (1-5 mapped from raw)
   - `display_inline() -> str`: "Title +2 | Tech +2 | Remote +1 | Salary 0 = 5" (per user decision format)
   - `display_with_keywords() -> str`: "Title +2 | Tech +2 (Kubernetes, Python) | Remote +1 | Salary 0 = 5" (for detail view -- Claude's discretion: show matched keywords)
   - `to_dict() -> dict`: for JSON storage in SQLite

2. Add `score_job_with_breakdown(job: Job) -> tuple[int, ScoreBreakdown]`:
   - Calls the same `_title_score`, `_tech_score`, `_location_score`, `_salary_score` methods
   - `_tech_score` needs modification to ALSO return matched keywords. Refactor to `_tech_score_detailed(job) -> tuple[int, list[str]]`.
   - Constructs ScoreBreakdown from individual scores
   - Maps raw weighted sum to 1-5 scale (same mapping as existing `score_job`)

3. Keep existing `score_job(job) -> int` working unchanged for backward compatibility.

4. Add `score_batch_with_breakdown(jobs: list[Job]) -> list[Job]`:
   - Like `score_batch` but also sets a `_breakdown` attribute on each Job (or stores breakdown in a returned dict). Since Job is Pydantic and we don't want to add ScoreBreakdown (a dataclass) as a Pydantic field, return `list[tuple[Job, ScoreBreakdown]]` instead. The orchestrator will handle storing the breakdown JSON in the db dict.

   Actually, simpler approach: return `list[tuple[Job, ScoreBreakdown]]` from `score_batch_with_breakdown`. The orchestrator extracts both.

5. The 4 scoring factors stay exactly as they are per user decision: "Current 5 scoring factors are sufficient... no new factors." (The "5 factors" in CONTEXT.md includes seniority which is already part of title match. Display uses 4 labels: Title, Tech, Remote, Salary.)
  </action>
  <verify>
Run: `python -c "
from scorer import JobScorer, ScoreBreakdown
from models import Job
j = Job(platform='indeed', title='Principal Engineer - Kubernetes', company='Google', url='http://x', location='Remote', description='kubernetes python terraform cloud infrastructure', salary_max=250000)
scorer = JobScorer()
score = scorer.score_job(j)
score2, breakdown = scorer.score_job_with_breakdown(j)
assert score == score2, f'{score} != {score2}'
assert isinstance(breakdown, ScoreBreakdown)
assert breakdown.title_points > 0
assert breakdown.tech_points > 0
assert breakdown.remote_points > 0
assert breakdown.total == score
assert 'Title' in breakdown.display_inline()
assert '=' in breakdown.display_inline()
d = breakdown.to_dict()
assert 'title' in d and 'tech' in d
print(f'Score: {score}, Breakdown: {breakdown.display_inline()}')
print(f'With keywords: {breakdown.display_with_keywords()}')
print('scorer OK')
"
`
  </verify>
  <done>ScoreBreakdown captures per-factor points. display_inline() matches user's required format "Title +2 | Tech +2 | Remote +1 | Salary 0 = 5". Existing score_job returns identical results (backward compatible). score_batch_with_breakdown returns jobs paired with breakdowns.</done>
</task>

</tasks>

<verification>
1. `python -c "from salary import parse_salary; from dedup import fuzzy_deduplicate; from scorer import ScoreBreakdown; print('All imports OK')"` -- all modules importable
2. Salary parser handles edge cases: None input, empty string, hourly, monthly, K notation, currency detection
3. Dedup merges close variants, rejects distant companies
4. ScoreBreakdown.display_inline() matches exact format from CONTEXT.md
5. Existing `scorer.score_job()` returns same results as before (backward compatible)
6. `python -c "import models; j = models.Job(platform='indeed', title='T', company='C', url='U'); print(j.company_aliases, j.salary_display, j.salary_currency)"` -- new fields have correct defaults
7. NormalizedSalary fields (min_annual, max_annual, currency, display) map correctly to Job model fields (salary_min, salary_max, salary_currency, salary_display) and round-trip through model_dump(mode='json')
</verification>

<success_criteria>
- salary.py parses all known formats from Indeed, Dice, RemoteOK without error
- dedup.py merges "Google"/"Google LLC" and keeps "Google"/"Alphabet" separate
- scorer.py returns ScoreBreakdown with display matching "Title +N | Tech +N | Remote +N | Salary +N = N"
- models.py Job has company_aliases (list[str]), salary_display (str), salary_currency (str)
- rapidfuzz>=3.14 in pyproject.toml
- All existing imports and usages of scorer.score_job / scorer.score_batch still work
- NormalizedSalary -> Job field mapping verified end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/03-discovery-engine/03-01-SUMMARY.md`
</output>
