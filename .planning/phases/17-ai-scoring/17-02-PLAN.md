---
phase: 17-ai-scoring
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - webapp/app.py
  - webapp/templates/partials/ai_score_result.html
  - webapp/templates/job_detail.html
autonomous: true

must_haves:
  truths:
    - "Clicking AI Rescore button on job detail page triggers POST to /jobs/{key}/ai-rescore and shows loading indicator"
    - "After AI scoring completes, the result (score, reasoning, strengths, gaps) renders in the ai-score-result div"
    - "If AI scoring fails, a red error box appears with the error message and existing rule-based score is unaffected"
    - "If a job already has an AI score, it displays on page load without clicking the button"
    - "If job description is too short (<50 chars), an error message is returned instead of calling the AI"
  artifacts:
    - path: "webapp/app.py"
      provides: "POST /jobs/{key}/ai-rescore endpoint"
      contains: "ai_rescore_endpoint"
    - path: "webapp/templates/partials/ai_score_result.html"
      provides: "htmx partial rendering AI score, reasoning, strengths, gaps"
      min_lines: 15
    - path: "webapp/templates/job_detail.html"
      provides: "AI Rescore button and persisted score display section"
      contains: "ai-rescore"
  key_links:
    - from: "webapp/app.py"
      to: "ai_scorer.score_job_ai"
      via: "lazy import and await in endpoint"
      pattern: "from ai_scorer import score_job_ai"
    - from: "webapp/app.py"
      to: "webapp/db.py update_ai_score"
      via: "stores result after scoring"
      pattern: "db\\.update_ai_score"
    - from: "webapp/templates/job_detail.html"
      to: "/jobs/{key}/ai-rescore"
      via: "hx-post attribute on button"
      pattern: "hx-post.*ai-rescore"
    - from: "webapp/templates/job_detail.html"
      to: "webapp/templates/partials/ai_score_result.html"
      via: "hx-target swaps partial into #ai-score-result"
      pattern: "hx-target.*ai-score-result"
---

<objective>
Wire the AI scoring feature into the dashboard: POST endpoint that orchestrates scoring + storage, htmx partial for result display, and job detail page UI with button and persisted score display.

Purpose: Completes the user-facing feature -- users can click a button on any job to get an AI-powered semantic analysis.
Output: Working AI Rescore button on job detail page, result display, error handling, persisted score on reload.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-ai-scoring/17-RESEARCH.md
@.planning/phases/17-ai-scoring/17-01-SUMMARY.md

@webapp/app.py
@webapp/db.py
@webapp/templates/job_detail.html
@webapp/templates/partials/resume_diff.html
@ai_scorer.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add POST endpoint and htmx partial for AI rescore</name>
  <files>webapp/app.py, webapp/templates/partials/ai_score_result.html</files>
  <action>
**1. Create `webapp/templates/partials/ai_score_result.html`:**

This partial renders the AI score result after a successful scoring call. It receives template variables: `score`, `reasoning`, `strengths`, `gaps`, `scored_at`.

```html
<div class="bg-blue-50 border border-blue-300 rounded-lg p-4">
    <div class="flex items-center justify-between mb-3">
        <h3 class="text-sm font-semibold text-blue-900">AI Analysis</h3>
        <span class="text-2xl score-{{ score }}">{{ score }}</span>
    </div>
    <p class="text-sm text-gray-700 mb-3">{{ reasoning }}</p>
    {% if strengths %}
    <div class="mb-2">
        <p class="text-xs font-semibold text-green-700 mb-1">Strengths</p>
        <ul class="text-xs text-gray-600 list-disc list-inside">
            {% for s in strengths %}
            <li>{{ s }}</li>
            {% endfor %}
        </ul>
    </div>
    {% endif %}
    {% if gaps %}
    <div>
        <p class="text-xs font-semibold text-red-700 mb-1">Gaps</p>
        <ul class="text-xs text-gray-600 list-disc list-inside">
            {% for g in gaps %}
            <li>{{ g }}</li>
            {% endfor %}
        </ul>
    </div>
    {% endif %}
    <p class="text-xs text-gray-400 mt-2">Scored at {{ scored_at }}</p>
</div>
```

**2. Add POST endpoint to `webapp/app.py`:**

Add the AI rescore endpoint in the "Resume AI endpoints" section (after the cover_letter_endpoint, BEFORE the serve_tailored_resume route and BEFORE the catch-all GET `/jobs/{dedup_key:path}` route). This is critical -- the POST route MUST be registered before the catch-all GET route at line 578.

Insert after the `cover_letter_endpoint` function (after line 422) and before the `serve_tailored_resume` function (line 425):

```python
@app.post("/jobs/{dedup_key:path}/ai-rescore", response_class=HTMLResponse)
async def ai_rescore_endpoint(request: Request, dedup_key: str):
    """Score a job using AI semantic analysis via Claude CLI."""
    job = db.get_job(dedup_key)
    if not job:
        return HTMLResponse("<h1>Job not found</h1>", status_code=404)

    # Guard: description must be substantial enough for analysis
    description = job.get("description") or ""
    if len(description.strip()) < 50:
        return HTMLResponse(
            '<div class="bg-yellow-50 border border-yellow-400 text-yellow-800 px-4 py-3 rounded">'
            '<p class="font-bold">Cannot analyze</p>'
            '<p class="text-sm">Job description is too short for AI analysis. '
            'Try refreshing the job listing first.</p>'
            '</div>'
        )

    try:
        from ai_scorer import score_job_ai
        from resume_ai.extractor import extract_resume_text

        # Resolve resume path (same pattern as tailor_resume_endpoint)
        resume_path = DEFAULT_RESUME_PATH
        try:
            from config import get_settings
            settings = get_settings()
            if settings.candidate_resume_path:
                resume_path = settings.candidate_resume_path
        except Exception:
            pass

        resume_text = extract_resume_text(resume_path)

        # Call AI scorer (natively async via claude_cli)
        result = await score_job_ai(
            resume_text=resume_text,
            job_description=description,
            job_title=job["title"],
            company_name=job["company"],
        )

        # Persist to database
        breakdown = {
            "reasoning": result.reasoning,
            "strengths": result.strengths,
            "gaps": result.gaps,
        }
        db.update_ai_score(dedup_key, result.score, breakdown)

        # Return htmx partial
        return templates.TemplateResponse(
            request,
            "partials/ai_score_result.html",
            {
                "score": result.score,
                "reasoning": result.reasoning,
                "strengths": result.strengths,
                "gaps": result.gaps,
                "scored_at": "just now",
            },
        )

    except Exception as exc:
        logger.exception("AI scoring failed for %s", dedup_key)
        return HTMLResponse(
            f'<div class="bg-red-50 border border-red-400 text-red-800 px-4 py-3 rounded">'
            f'<p class="font-bold">AI Scoring Error</p>'
            f'<p class="text-sm">{exc}</p>'
            f'</div>'
        )
```

Use lazy imports inside the try block (same pattern as tailor_resume_endpoint and cover_letter_endpoint). This avoids import errors if dependencies are missing.

Verify: `uv run ruff check webapp/app.py` passes. `uv run ruff format webapp/app.py` applied.
  </action>
  <verify>
`uv run ruff check webapp/app.py webapp/templates/partials/ai_score_result.html` -- no lint errors on Python file.
`uv run pytest tests/ -x -q` -- full test suite still passes (endpoint exists but won't be called without mocks).
Confirm file exists: `ls webapp/templates/partials/ai_score_result.html`
  </verify>
  <done>POST /jobs/{key}/ai-rescore endpoint registered before catch-all GET, validates description length, calls score_job_ai, persists via update_ai_score, returns htmx partial or error div. Partial template renders score/reasoning/strengths/gaps.</done>
</task>

<task type="auto">
  <name>Task 2: Update job detail template with AI Rescore button and persisted score display</name>
  <files>webapp/templates/job_detail.html</files>
  <action>
Modify `webapp/templates/job_detail.html` to add an AI Analysis sidebar card.

**Location:** Insert a NEW sidebar card between the "AI Resume Tools" card (ends at line 159) and the "Apply" card (starts at line 162). This groups AI features together in the sidebar.

**New "AI Analysis" card structure:**

```html
<!-- AI Analysis -->
<div class="bg-white rounded-lg shadow-sm border p-6">
    <h2 class="text-lg font-semibold text-gray-900 mb-3">AI Analysis</h2>

    {% if job.ai_score %}
    {# Show persisted AI score #}
    {% set ai_bd = job.ai_score_breakdown | parse_json %}
    <div id="ai-score-result">
        <div class="bg-blue-50 border border-blue-300 rounded-lg p-4 mb-3">
            <div class="flex items-center justify-between mb-3">
                <h3 class="text-sm font-semibold text-blue-900">AI Analysis</h3>
                <span class="text-2xl score-{{ job.ai_score }}">{{ job.ai_score }}</span>
            </div>
            <p class="text-sm text-gray-700 mb-3">{{ ai_bd.reasoning }}</p>
            {% if ai_bd.strengths %}
            <div class="mb-2">
                <p class="text-xs font-semibold text-green-700 mb-1">Strengths</p>
                <ul class="text-xs text-gray-600 list-disc list-inside">
                    {% for s in ai_bd.strengths %}
                    <li>{{ s }}</li>
                    {% endfor %}
                </ul>
            </div>
            {% endif %}
            {% if ai_bd.gaps %}
            <div>
                <p class="text-xs font-semibold text-red-700 mb-1">Gaps</p>
                <ul class="text-xs text-gray-600 list-disc list-inside">
                    {% for g in ai_bd.gaps %}
                    <li>{{ g }}</li>
                    {% endfor %}
                </ul>
            </div>
            {% endif %}
            <p class="text-xs text-gray-400 mt-2">Scored {{ job.ai_scored_at }}</p>
        </div>
    </div>
    <button hx-post="/jobs/{{ job.dedup_key | urlencode }}/ai-rescore"
            hx-target="#ai-score-result"
            hx-swap="innerHTML"
            hx-indicator="#ai-score-spinner"
            class="w-full bg-amber-600 text-white px-4 py-2 rounded text-sm hover:bg-amber-700">
        Rescore
    </button>
    {% else %}
    {# No AI score yet -- show button #}
    <div id="ai-score-result"></div>
    <button hx-post="/jobs/{{ job.dedup_key | urlencode }}/ai-rescore"
            hx-target="#ai-score-result"
            hx-swap="innerHTML"
            hx-indicator="#ai-score-spinner"
            class="w-full bg-amber-600 text-white px-4 py-2 rounded text-sm hover:bg-amber-700">
        AI Rescore
    </button>
    {% endif %}

    <div id="ai-score-spinner" class="htmx-indicator text-center py-4">
        <span class="text-sm text-gray-500">Analyzing job fit... this may take 10-15 seconds</span>
    </div>
</div>
```

Key design decisions:
- **Button text:** "AI Rescore" when no score exists, "Rescore" when one already exists (per pitfall 5 in research)
- **Button color:** amber-600 to differentiate from the indigo/emerald/purple buttons used by other features
- **hx-indicator:** Shows loading text during the CLI call (~10-15 seconds)
- **Persisted score:** Uses the `parse_json` filter (already registered on the template env) to decode ai_score_breakdown
- **hx-target:** Always targets `#ai-score-result` -- when rescoring, the new result replaces the old

Also add an `ai_scored` event type to the activity timeline section. In the activity timeline block (around line 235-240), add a new condition for the `ai_scored` event type:

```html
{% elif event.event_type == 'ai_scored' %}
    AI scored: {{ event.new_value }}/5
```

And add the dot color for it (around line 237):
```html
{% elif event.event_type == 'ai_scored' %}bg-amber-400
```
  </action>
  <verify>
Open `webapp/templates/job_detail.html` and confirm:
1. AI Analysis card exists between AI Resume Tools and Apply cards
2. Conditional rendering for existing vs new AI score
3. hx-post points to /jobs/{key}/ai-rescore
4. hx-indicator references #ai-score-spinner
5. Activity timeline handles ai_scored event type
`uv run pytest tests/ -x -q` -- full suite passes.
  </verify>
  <done>Job detail page has AI Analysis sidebar card with: persisted score display on load (if exists), AI Rescore/Rescore button with loading indicator, htmx POST targeting result div, and activity timeline support for ai_scored events.</done>
</task>

</tasks>

<verification>
1. `uv run ruff check webapp/app.py` -- no lint errors
2. `uv run pytest tests/ -x -q` -- full test suite passes
3. Visual inspection: job_detail.html has AI Analysis card between AI Resume Tools and Apply sections
4. Route ordering: ai-rescore POST endpoint is registered BEFORE the catch-all GET /jobs/{dedup_key:path}
5. Template partial exists: `webapp/templates/partials/ai_score_result.html`
</verification>

<success_criteria>
- POST /jobs/{key}/ai-rescore endpoint exists and handles: success (returns partial), short description (returns warning), CLI error (returns error div), job not found (returns 404)
- htmx partial ai_score_result.html renders score, reasoning, strengths, gaps
- job_detail.html shows persisted AI score on load when ai_score column is populated
- job_detail.html shows AI Rescore button that triggers POST with loading indicator
- Activity timeline displays ai_scored events
- Full test suite passes with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/17-ai-scoring/17-02-SUMMARY.md`
</output>
